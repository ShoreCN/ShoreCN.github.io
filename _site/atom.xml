<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-25T15:28:58+08:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Shore Space</title><subtitle>C/Python/通信/云计算/Docker/K8S</subtitle><author><name>Shore</name></author><entry><title type="html">个人技能树</title><link href="http://localhost:4000/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities/" rel="alternate" type="text/html" title="个人技能树" /><published>2023-08-24T23:17:19+08:00</published><updated>2023-08-24T23:17:19+08:00</updated><id>http://localhost:4000/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities</id><content type="html" xml:base="http://localhost:4000/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities/">&lt;p&gt;个人技能情况:
&lt;img src=&quot;/resource/个人技能树(20230822).png&quot; alt=&quot;个人技能树&quot; /&gt;&lt;/p&gt;</content><author><name>Shore</name></author><category term="个人" /><category term="简历" /><summary type="html">个人技能情况:</summary></entry><entry><title type="html">区块链代币管理</title><link href="http://localhost:4000/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager/" rel="alternate" type="text/html" title="区块链代币管理" /><published>2023-05-12T01:23:59+08:00</published><updated>2023-05-12T01:23:59+08:00</updated><id>http://localhost:4000/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager</id><content type="html" xml:base="http://localhost:4000/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager/">&lt;p&gt;区块链代币管理&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;区块链代币种类繁多, 如何在项目里面合理地管理代币, 这是一个问题.&lt;br /&gt;
通常情况下项目规模不大, 代币种类也不是很多, 可以直接在代码里面硬编码, 前端和后端各自独立维护, 但是这样的话, 项目的可扩展性和维护性就比较差.&lt;br /&gt;
通过设计一个简单的代币管理模块, 可以有效地解决这个问题.&lt;/p&gt;

&lt;h2 id=&quot;设计思路&quot;&gt;设计思路&lt;/h2&gt;
&lt;h3 id=&quot;明确需求&quot;&gt;明确需求&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;准确性有保证, 代币数据准确无误;&lt;/li&gt;
  &lt;li&gt;可维护性强, 统一管理代币, 避免重复劳动且容易出错;&lt;/li&gt;
  &lt;li&gt;便捷性较好, 通过设计灵活的接口, 可以适应不同的业务场景.&lt;/li&gt;
  &lt;li&gt;稳定性高, 单数据源容易出现异常时, 代币数据可能会丢失或无法读取;&lt;/li&gt;
  &lt;li&gt;可扩展性好, 代币种类可以动态增加, 代币属性可以动态修改;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;设计方案&quot;&gt;设计方案&lt;/h3&gt;
&lt;h4 id=&quot;数据结构&quot;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;代币通常需要包含以下属性:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代币名称&lt;/li&gt;
  &lt;li&gt;代币符号&lt;/li&gt;
  &lt;li&gt;代币精度&lt;/li&gt;
  &lt;li&gt;代币合约地址&lt;/li&gt;
  &lt;li&gt;代币图标&lt;/li&gt;
  &lt;li&gt;链类型&lt;/li&gt;
  &lt;li&gt;协议类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在同一条链上, 代币符号常常无法保证唯一性, 例如: USDT, 代币名称可以保证唯一性, 例如: Tether USD.&lt;br /&gt;
在不同链上, 代币符号也可能相同, 例如: USDT.&lt;br /&gt;
所以我们需要一个唯一的标识来区分不同链上的代币, 这里我们使用代币名称+链类型来作为唯一标识.&lt;/p&gt;

&lt;h4 id=&quot;数据存储&quot;&gt;数据存储&lt;/h4&gt;
&lt;p&gt;代币数据的持久化存储, 通常有以下几种方案:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库&lt;/li&gt;
  &lt;li&gt;文件&lt;/li&gt;
  &lt;li&gt;缓存
对于token这类型的数据, 数据库可以选择非关系型数据库, 例如: mongodb, redis等.
缓存可以选择本地内存缓存, 规模较大的话, 可以选择分布式缓存, 例如: redis, memcached等.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;仅使用单数据源的话, 会存在以下问题:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;单数据源容易出现异常时, 代币数据可能会丢失或无法读取;&lt;/li&gt;
  &lt;li&gt;单数据源无法保证数据的准确性, 例如: 代币数据被恶意篡改, 或者数据更新不同步等;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这个问题, 我们可以使用多数据源的方案, 例如: 数据库+缓存, 数据库+文件等.&lt;/p&gt;

&lt;p&gt;不过多数据源的方案, 会存在数据同步的问题, 例如: 数据库+缓存, 数据库中的数据被修改后, 缓存中的数据没有及时更新, 会导致数据不一致. 通过设计一个简单的数据同步机制, 可以有效地解决这个问题.
同步机制的设计思路如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库中的数据被修改后, 通过消息队列发送消息;&lt;/li&gt;
  &lt;li&gt;缓存中的数据订阅消息队列, 收到消息后, 更新缓存中的数据;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;接口设计&quot;&gt;接口设计&lt;/h4&gt;
&lt;p&gt;代币管理系统的接口设计, 通常需要包含以下几个方面:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据初始化&lt;/li&gt;
  &lt;li&gt;数据的读取&lt;/li&gt;
  &lt;li&gt;数据的更新&lt;/li&gt;
  &lt;li&gt;数据的删除&lt;/li&gt;
  &lt;li&gt;数据的同步&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;对象设计&quot;&gt;对象设计&lt;/h4&gt;

&lt;h2 id=&quot;实现方案&quot;&gt;实现方案&lt;/h2&gt;
&lt;h3 id=&quot;数据结构-1&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;代币数据的基础结构如下:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;token_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;precision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;logo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据存储-1&quot;&gt;数据存储&lt;/h3&gt;
&lt;p&gt;代币数据的存储方案如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库: mongodb&lt;/li&gt;
  &lt;li&gt;缓存: LocalCache&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;接口实现&quot;&gt;接口实现&lt;/h3&gt;
&lt;p&gt;代币管理系统的接口设计如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据初始化: 从数据库中读取数据, 并写入缓存, 如果数据库中没有数据, 则从读取预先硬编码的代币数据, 并写入数据库和缓存;&lt;/li&gt;
  &lt;li&gt;数据的读取: 从缓存中读取数据, 如果缓存中没有数据, 则从数据库中读取数据, 并写入缓存;&lt;/li&gt;
  &lt;li&gt;数据的更新: 更新数据库中的数据, 并通知缓存更新数据;&lt;/li&gt;
  &lt;li&gt;数据的删除: 删除数据库中的数据, 并通知缓存删除数据;&lt;/li&gt;
  &lt;li&gt;数据的同步: 定时检查数据库和缓存中的数据是否一致, 如果不一致, 则更新缓存中的数据; 定时检查数据库中的数据和外部数据(区块链浏览器,服务提供商等)是否一致, 如果不一致, 则更新数据库中的数据;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;对象实现&quot;&gt;对象实现&lt;/h3&gt;
&lt;p&gt;以python为例, 代币管理系统的对象如下:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CryptoTokenManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;restore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;恢复数据
        外部数据(暂无) &amp;gt; 数据库 &amp;gt; 默认数据 &amp;gt; 内存

        Returns:
            list: 恢复的数据
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;获取token信息

        Args:
            token (str): token名称
            chain (str): 链

        Returns:
            dict: token信息
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_token_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;获取token列表

        Args:
            token (str, optional): token名称. Defaults to &apos;&apos;.
            chain (str, optional): 链. Defaults to &apos;&apos;.
            protocol (str, optional): 协议. Defaults to &apos;&apos;.

        Returns:
            list: token列表
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;添加token(本地)

        Args:
            token_info (dict): token信息

        Returns:
            bool: 是否添加成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;移除token(本地)

        Args:
            token (str): token名称
            chain (str): 链
        
        Returns:
            bool: 是否移除成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;保存至数据库

        Returns:
            bool: 是否保存成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;检查数据是否正确

        Returns:
            bool: 是否正确
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考🤔&lt;/h2&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;性能优化&lt;/h3&gt;
&lt;p&gt;因为代币数据的读取频率远远大于写入频率, 所以我们可以通过缓存来提高读取性能. 作为一个相对静态的数据, 后续还可以考虑通过CDN来提升网络接口表现.&lt;/p&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;
&lt;p&gt;代币数据的安全性关键就是保证数据的准确性, 具体来说就是数据的非预期篡改, 例如: 代币数据被恶意篡改, 或者数据更新错误等.&lt;br /&gt;
不过代币管理虽然贯穿了大部分的业务流程, 但是错误的代币地址通常导致的是业务流程的失败, 而不是错误的业务流程(例如资产流向错误目标等), 所以对于安全性的提升可以更加侧重于密钥管理/收款方确认等方面.&lt;/p&gt;

&lt;h3 id=&quot;后续优化方案&quot;&gt;后续优化方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;外部数据同步&lt;/li&gt;
  &lt;li&gt;异常处理&lt;/li&gt;
  &lt;li&gt;告警机制&lt;/li&gt;
  &lt;li&gt;数据存储简化&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Shore</name></author><category term="架构" /><category term="区块链" /><category term="Python" /><category term="加密货币" /><summary type="html">区块链代币管理</summary></entry><entry><title type="html">区块链地址标准及编码解码</title><link href="http://localhost:4000/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec/" rel="alternate" type="text/html" title="区块链地址标准及编码解码" /><published>2023-04-01T23:44:29+08:00</published><updated>2023-04-01T23:44:29+08:00</updated><id>http://localhost:4000/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec</id><content type="html" xml:base="http://localhost:4000/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec/">&lt;p&gt;区块链地址标准及编码解码&lt;/p&gt;
&lt;h2 id=&quot;数据类型-地址-address&quot;&gt;数据类型-地址 address&lt;/h2&gt;
&lt;p&gt;在solidity里的address等价于 uint160, 即长度20字节的数值&lt;br /&gt;
在大部分开发语言内部通常使用十六进制格式进行操作(fe1f0e6efead80045af5ddb58b664fb6492230e3)&lt;br /&gt;
有时显示时加上0x标明这是一个十六进制格式(0xfe1f0e6efead80045af5ddb58b664fb6492230e3)&lt;/p&gt;

&lt;h2 id=&quot;checksum格式字符串&quot;&gt;CheckSum格式字符串&lt;/h2&gt;
&lt;p&gt;为了防止输入错误或者其他复制、粘贴、传输地址等情况出现失误, EIP-55制定了一套地址编码规则&lt;br /&gt;
样例: 0xfE1f0e6EFEad80045Af5ddb58b664fb6492230E3&lt;/p&gt;

&lt;h3 id=&quot;产生规则&quot;&gt;产生规则&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;将地址转换为十六进制结果(fe1f0e6efead80045af5ddb58b664fb6492230e3)
进行一次Keccak256哈希处理, 得到参照表(1ea1041c8817750ddd7e542a4754354676f5deb7ce20334eccf0936e81ba8726)&lt;/li&gt;
  &lt;li&gt;遍历十六进制结果的每个字符,数字跳过, 字母处理, 使用参照表里相同位置的数值进行判断, 如果小于8则不变化, 大于8则变成大写字母(fE1f0e6EFEad80045Af5ddb58b664fb6492230E3)&lt;/li&gt;
  &lt;li&gt;加上0x头, 得到最终结果(0xfE1f0e6EFEad80045Af5ddb58b664fb6492230E3)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;eth地址&quot;&gt;ETH地址&lt;/h2&gt;
&lt;p&gt;使用如上规则&lt;/p&gt;
&lt;h2 id=&quot;tron地址&quot;&gt;TRON地址&lt;/h2&gt;
&lt;h3 id=&quot;支持hex格式地址&quot;&gt;支持Hex格式地址&lt;/h3&gt;
&lt;p&gt;(官方文档说法) 同一个私钥生成的Hex格式TRON地址和以太坊地址相比，除了最前面加上41，其他完全一样&lt;br /&gt;
&lt;strong&gt;所以TRON地址是21字节长度&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;支持base58check格式地址&quot;&gt;支持Base58Check格式地址&lt;/h3&gt;
&lt;p&gt;(官方文档说法) 对Hex格式的地址进行basecheck计算得到Base58格式地址，所有账户地址的第一个字符均为T&lt;br /&gt;
样例: TWEkjtFFeVtfsdRT32Xx5KuWGcskYfhWjX&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;地址前面添加版本前缀可以影响编码结果的前导符号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;产生规则-1&quot;&gt;产生规则&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;取版本字段(41)和有效负载信息(de533fbbb750d302728d3ad29d31e070bc14af4b)，并将它们连接在一起(41de533fbbb750d302728d3ad29d31e070bc14af4b)&lt;/li&gt;
  &lt;li&gt;对第一步结果进行两次SHA256变换，取结果的前4个字节, 作为校验内容(6421c276)&lt;/li&gt;
  &lt;li&gt;将第一步结果和第二步结果连接在一起(41de533fbbb750d302728d3ad29d31e070bc14af4b6421c276)&lt;/li&gt;
  &lt;li&gt;进行base58 encode, 得到结果(TWEkjtFFeVtfsdRT32Xx5KuWGcskYfhWjX)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;但是在 TVM 虚拟机和 Solidity 编程中，需要再去掉前缀 41 成为和以太坊兼容的20字节地址格式&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;application-binary-interfaceabi&quot;&gt;Application Binary Interface(ABI)&lt;/h2&gt;
&lt;p&gt;ABI即应用二进制接口, 作为与智能合约交互的标准, 起到交互数据的作用&lt;/p&gt;

&lt;h3 id=&quot;结构&quot;&gt;结构&lt;/h3&gt;
&lt;p&gt;数据由函数选择器和参数编码组成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;函数选择器Function Selector&lt;br /&gt;
函数签名的 Keccak（SHA-3）哈希的前 4 字节&lt;br /&gt;
基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;例如transfer(address,uint256)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;参数编码&lt;br /&gt;
从第5字节开始是被编码的参数&lt;br /&gt;
动态类型(bytes,string,list,tuple)和静态类型(其他)&lt;br /&gt;
编码规则
    &lt;ul&gt;
      &lt;li&gt;转换为十六进制之后补齐到32字节长度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三方库&quot;&gt;第三方库&lt;/h3&gt;
&lt;p&gt;后端Python使用eth-abi库进行编码解码
iOS
Android&lt;/p&gt;

&lt;h3 id=&quot;调用链条&quot;&gt;调用链条&lt;/h3&gt;
&lt;h4 id=&quot;eth&quot;&gt;ETH&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前端-SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
  &lt;li&gt;后端-Web3 SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tron&quot;&gt;TRON&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前端-SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
  &lt;li&gt;后端-编码(eth-abi)-发送请求至节点服务商-区块链
    &lt;ul&gt;
      &lt;li&gt;编码过程中将TRON地址的首字节去除&lt;/li&gt;
      &lt;li&gt;logic.contract_tron_logic.TronContractInterface.execute_contract_func -&amp;gt; trx_abi.encode_single&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tron-地址的特殊处理&quot;&gt;TRON 地址的特殊处理&lt;/h2&gt;
&lt;p&gt;由于 EVM 中 address 为 20 字节 bytes160 类型，而 TRON 地址的 hex 地址为 21 字节， 所以在传入参数的时候需要截取后 20 字节&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TVM 对 21 字节地址只有有限的支持，建议不要依赖此特性&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;衍生&quot;&gt;衍生&lt;/h2&gt;
&lt;p&gt;bytes数据格式, 可转换为十六进制的字符串进行传递, 不需要加0x头&lt;/p&gt;

&lt;h2 id=&quot;参考产品&quot;&gt;参考产品&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;TronLink&lt;br /&gt;
进行Token转账时产生的data数据里面地址没有41前缀&lt;/li&gt;
  &lt;li&gt;imToken&lt;br /&gt;
未测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERC-55: Mixed-case checksum address encoding
https://eips.ethereum.org/EIPS/eip-55&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用二进制接口Application Binary Interface(ABI) 说明
https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;TRON协议-账户地址格式
https://cn.developers.tron.network/docs/&amp;gt; account#%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;TRON参数编码和解码
https://cn.developers.tron.network/docs/parameter-encoding-and-decoding&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Solidity ABI - TRON 地址的特殊处理TRON 地址的特殊处理
https://andelf.gitbook.io/tron/smart-contract/abi&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;List of address prefixes
https://en.bitcoin.it/wiki/List_of_address_prefixes&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="区块链" /><category term="加密货币" /><category term="TRON" /><category term="以太坊" /><summary type="html">区块链地址标准及编码解码 数据类型-地址 address 在solidity里的address等价于 uint160, 即长度20字节的数值 在大部分开发语言内部通常使用十六进制格式进行操作(fe1f0e6efead80045af5ddb58b664fb6492230e3) 有时显示时加上0x标明这是一个十六进制格式(0xfe1f0e6efead80045af5ddb58b664fb6492230e3)</summary></entry><entry><title type="html">公网ssh访问局域网内部Mac主机</title><link href="http://localhost:4000/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh/" rel="alternate" type="text/html" title="公网ssh访问局域网内部Mac主机" /><published>2023-01-04T18:01:00+08:00</published><updated>2023-01-04T18:01:00+08:00</updated><id>http://localhost:4000/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh</id><content type="html" xml:base="http://localhost:4000/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh/">&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;
&lt;p&gt;我们的日常网络应用都是基于公网IP进行的，那么如果电脑处在于某个局域网内（例如公司网络、校园网络等情况），那么就常常出现使用公网IP无法访问的情况。要解决此问题涉及如下两部分配置：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mac端启动sshd服务&lt;/li&gt;
  &lt;li&gt;配置端口映射用以内访问内网设备&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1mac端启动sshd服务&quot;&gt;1.Mac端启动sshd服务&lt;/h1&gt;

&lt;p&gt;系统版本：macOS High Sierra 10.13.1 (17B1003)
macOS系统自带了sshd服务，只需要启动即可，使用如下命令：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 启动sshd服务
sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 停止sshd服务
sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看sshd服务情况
sudo launchctl list | grep ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意事项：
此处需要格外注意，必须要使用具有root权限的用户启动sshd服务，否则可能会因无法访问ssh key导致客户端ssh连接失败
ssh_exchange_identification: Connection closed by remote host&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考资料
https://www.cnblogs.com/EasonJim/p/7173859.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;2端口映射外网访问局域网内部主机&quot;&gt;2.端口映射外网访问局域网内部主机&lt;/h1&gt;

&lt;p&gt;位于公司、校园等局域网环境下面的多台主机，共用的都是一个公网IP，
所以外网直接通过此公网IP+端口访问某个局域网主机必然会产生混乱，此时就需要配置端口映射。&lt;/p&gt;

&lt;p&gt;此处访问的是ssh服务，端口号为22，无法直接访问。
那么我们可以在局域网出口路由器上定义一个未使用的端口号（例如38998），映射到内网主机的端口22，具体如下：
外网终端 &amp;lt;–&amp;gt; 局域网出口路由器38998端口 &amp;lt;–&amp;gt; 内网主机22端口&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如此配置完之后，在外网就可以通过自定义的端口号和公网IP就可以访问内网的主机了&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh user_name@server_ip -p 38998&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果需要通过ssh拷贝文件的话，可以采用scp命令&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scp -P 38998 src_file user_name@server_ip:dst_file&lt;/code&gt;&lt;/p&gt;</content><author><name>Shore</name></author><category term="工具" /><category term="ssh" /><category term="macOS" /><summary type="html">需求 我们的日常网络应用都是基于公网IP进行的，那么如果电脑处在于某个局域网内（例如公司网络、校园网络等情况），那么就常常出现使用公网IP无法访问的情况。要解决此问题涉及如下两部分配置： Mac端启动sshd服务 配置端口映射用以内访问内网设备</summary></entry><entry><title type="html">vscode的列编辑模式</title><link href="http://localhost:4000/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode/" rel="alternate" type="text/html" title="vscode的列编辑模式" /><published>2022-11-29T00:00:00+08:00</published><updated>2022-11-29T00:00:00+08:00</updated><id>http://localhost:4000/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode</id><content type="html" xml:base="http://localhost:4000/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode/">&lt;h2 id=&quot;列编辑模式&quot;&gt;列编辑模式&lt;/h2&gt;
&lt;p&gt;在原来使用notepad++的时候，经常使用列编辑模式，可以快速地对多行文本进行编辑。最近使用vscode，发现vscode也有类似的功能，记录一下。&lt;/p&gt;

&lt;p&gt;目前, vscode提供了以下几种使用列编辑模式的方式:&lt;/p&gt;
&lt;h2 id=&quot;鼠标操作-多光标&quot;&gt;鼠标操作: 多光标&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;点击鼠标左键, 选择需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;这样操作会产生多个光标, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;鼠标操作-框选&quot;&gt;鼠标操作: 框选&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本的起始位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;按住鼠标左键, 拖动鼠标, 选择需要编辑的文本;&lt;/li&gt;
  &lt;li&gt;这样操作会产生一个矩形的跨行选框, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;键盘操作-多光标&quot;&gt;键盘操作: 多光标&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Command&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;上/下&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;这样操作可以产生多个光标, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 以上操作都是在MacOS系统下进行的, Windows系统下的快捷键可能会有所不同.&lt;br /&gt;
大部分情况下, 二者的快捷键可以使用如下方式对应:&lt;br /&gt;
MacOS的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;键对应Windows的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alt&lt;/code&gt;键;&lt;br /&gt;
MacOS的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Command&lt;/code&gt;键对应Windows的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;键;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="工具" /><category term="vscode" /><summary type="html">列编辑模式 在原来使用notepad++的时候，经常使用列编辑模式，可以快速地对多行文本进行编辑。最近使用vscode，发现vscode也有类似的功能，记录一下。</summary></entry><entry><title type="html">macOS上修复word/excel等office文件乱码问题</title><link href="http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac/" rel="alternate" type="text/html" title="macOS上修复word/excel等office文件乱码问题" /><published>2019-03-19T19:14:39+08:00</published><updated>2019-03-19T19:14:39+08:00</updated><id>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac</id><content type="html" xml:base="http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac/">&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;编码问题。因为在Windows系统上面，通常使用的是GBK字符编码方式，但是在macOS的系统上使用的是UTF-8的编码方式。所以常常会遇到从Windows系统上编辑创建的word/excel等office文件，在macOS或iOS上面打开显示为乱码。&lt;/p&gt;

&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;既然明白了问题产生原因是字符编码方式的差异，那么就容易处理了，我们只需要将文件的字符编码方式转换为系统支持的即可。
macOS或Linux系统下的iconv命令的作用就是进行文件编码方式转换。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iconv的作用是在多种国际编码格式之间进行文本内码的转换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: iconv [OPTION...] [-f ENCODING] [-t ENCODING] [INPUTFILE...]
or:    iconv -l

Converts text from one encoding to another encoding.

Options controlling the input and output format:
  -f ENCODING, --from-code=ENCODING
                              the encoding of the input
  -t ENCODING, --to-code=ENCODING
                              the encoding of the output

Options controlling conversion problems:
  -c                          discard unconvertible characters
  --unicode-subst=FORMATSTRING
                              substitution for unconvertible Unicode characters
  --byte-subst=FORMATSTRING   substitution for unconvertible bytes
  --widechar-subst=FORMATSTRING
                              substitution for unconvertible wide characters

Options controlling error output:
  -s, --silent                suppress error messages about conversion problems

Informative output:
  -l, --list                  list the supported encodings
  --help                      display this help and exit
  --version                   output version information and exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过iconv尝试进行文件编码方式转换，执行命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iconv -s -c -f GBK -t UTF8 input.file &amp;gt; output.file&lt;/code&gt;&lt;br /&gt;
参数解释：&lt;br /&gt;
-f 输入文件的编码方式&lt;br /&gt;
-t 输出文件的编码方式&lt;br /&gt;
input.file 输入文件名&lt;br /&gt;
output.file 输出文件名&lt;br /&gt;
通过执行这条命令，我们打开新生成的输出文件，可以看到文件内容已经正常显示了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iconv命令支持很多文件编码方式，具体的可以通过命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iconv -l&lt;/code&gt;进行查询。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="工具" /><summary type="html">原因 编码问题。因为在Windows系统上面，通常使用的是GBK字符编码方式，但是在macOS的系统上使用的是UTF-8的编码方式。所以常常会遇到从Windows系统上编辑创建的word/excel等office文件，在macOS或iOS上面打开显示为乱码。</summary></entry><entry><title type="html">在Google云平台上通过Docker快速搭建ShadowSocks服务</title><link href="http://localhost:4000/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker/" rel="alternate" type="text/html" title="在Google云平台上通过Docker快速搭建ShadowSocks服务" /><published>2019-03-06T06:46:49+08:00</published><updated>2019-03-06T06:46:49+08:00</updated><id>http://localhost:4000/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker</id><content type="html" xml:base="http://localhost:4000/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker/">&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;已激活的Google云账号&lt;/li&gt;
  &lt;li&gt;支付方式已经配置成功&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建实例&quot;&gt;创建实例&lt;/h2&gt;
&lt;p&gt;通过Google Cloud Platform左上角的导航菜单进入“Compute Engine - VM实例视图”创建VM实例
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择区域与配置&quot;&gt;选择区域与配置&lt;/h3&gt;
&lt;p&gt;目前谷歌云支持18个区域,列表如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Taiwan(asia-east1)&lt;/li&gt;
  &lt;li&gt;Hong Kong(asia-east2)&lt;/li&gt;
  &lt;li&gt;Singapore(asia-southeast1)&lt;/li&gt;
  &lt;li&gt;Tokyo(asia-northeast1)&lt;/li&gt;
  &lt;li&gt;Montreal, Canada(northamerica-northeast1)&lt;/li&gt;
  &lt;li&gt;Los Angeles, USA(us-west2)&lt;/li&gt;
  &lt;li&gt;South Carolina, USA(us-east1)&lt;/li&gt;
  &lt;li&gt;Northern Virginia, USA(us-east4)&lt;/li&gt;
  &lt;li&gt;Sydney(australia-southeast1)&lt;/li&gt;
  &lt;li&gt;Mumbai(asia-south1)&lt;/li&gt;
  &lt;li&gt;Belgium(europe-west1)&lt;/li&gt;
  &lt;li&gt;Netherlands(europe-west4)&lt;/li&gt;
  &lt;li&gt;Hamina, Finland(europe-north1)&lt;/li&gt;
  &lt;li&gt;London, UK(europe-west2)&lt;/li&gt;
  &lt;li&gt;Iowa, USA(us-central1)&lt;/li&gt;
  &lt;li&gt;Oregon, USA(us-west1)&lt;/li&gt;
  &lt;li&gt;São Paulo(southamerica-east1)&lt;/li&gt;
  &lt;li&gt;Frankfurt, Germany(europe-west3)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据业务选择适合自己的区域,通常选用访问延迟较低的区域,可以根据谷歌云主机测速网站&lt;a href=&quot;http://www.gcping.com/&quot;&gt;GCP ping&lt;/a&gt;的数据进行选择.
此处以台湾服务器为例
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;可选是否使用容器功能&quot;&gt;(可选)是否使用容器功能&lt;/h3&gt;
&lt;p&gt;Google云已经全流程支持容器功能,可以在创建实例的时候就进行容器配置
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择映像&quot;&gt;选择映像&lt;/h3&gt;
&lt;p&gt;如果使用容器化部署的话,系统会自动启用容器定制系统,用户就无需自己再选择映像了.
若没有使用到云平台配套的容器功能,用户可以根据需求选择合适自己的映像(即镜像)
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;防火墙配置&quot;&gt;防火墙配置&lt;/h3&gt;
&lt;p&gt;勾选允许HTTP和HTTPS流量的选项
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;连接实例&quot;&gt;连接实例&lt;/h2&gt;
&lt;p&gt;Google Cloud提供了浏览器登录、SSH登录等多种方式,选择合适自己的即可.&lt;/p&gt;

&lt;h2 id=&quot;手工使用docker部署shadowsocks服务&quot;&gt;手工使用Docker部署ShadowSocks服务&lt;/h2&gt;
&lt;p&gt;使用Google Cloud自带的容器功能可以省去一些安装配置动作.
但是手工部署可以带来更高的灵活性,用户可以选择更多的可选配置.
安装完docker相关组件之后,使用如下命令即可部署SS服务:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -dt --name ss -p &amp;lt;host_port&amp;gt;:&amp;lt;docker_port&amp;gt; mritd/shadowsocks -s &quot;-s 0.0.0.0 -p &amp;lt;s&amp;gt; -m chacha20-ietf-poly1305 -k &amp;lt;password&amp;gt; --fast-open&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数说明:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-d: 后台运行容器，并返回容器ID；&lt;/li&gt;
  &lt;li&gt;-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；&lt;/li&gt;
  &lt;li&gt;-p: 根据“服务器端口:容器端口”格式顺序配置端口映射关系&lt;/li&gt;
  &lt;li&gt;-s: 用户自行指定参数
    &lt;ul&gt;
      &lt;li&gt;-s  服务主机IP&lt;/li&gt;
      &lt;li&gt;-p 对外暴露的服务端口&lt;/li&gt;
      &lt;li&gt;-m 选择加密方式,这里选择chacha20-ietf-poly1305&lt;/li&gt;
      &lt;li&gt;-k 配置密码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令执行完成之后可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;命令查看容器是否正常运行,
使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep ss&lt;/code&gt;命令可以查看ShadowSocks服务是否正常运行.&lt;/p&gt;

&lt;p&gt;至此,用户就可以根据自己使用的终端安装对应的客户端使用ShadowSocks服务了.&lt;/p&gt;

&lt;h2 id=&quot;常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ShadowSocks安装及配置没有错误的情况下，客户端为何还是无法使用服务？
使用云服务器出现这种情况很可能是因为云厂商的网络安全策略限制所致，请确保相应的网络端口都已经打开。此处以谷歌云为例，导航菜单-VPC网络-防火墙规则-创建防火墙规则-填写允许访问的协议和端口。
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/6.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;tips 如何快速判断是因为网络端口没有放开导致的服务不可用？&lt;br /&gt;
有时用户无法确定到底是软件安装配置还是网络端口问题导致的服务不可用。只需如下一条命令即可快速启用一个web服务&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -p &amp;lt;hostPort&amp;gt;:80 -d nginx&lt;/code&gt;，通过访问hostIP:hostPort查看网页是否能够正常访问即可判断端口是否正常放开。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="云计算" /><category term="容器" /><category term="ShadowSocks" /><category term="Docker" /><category term="Google" /><summary type="html">准备 已激活的Google云账号 支付方式已经配置成功</summary></entry><entry><title type="html">AWS CloudFront CDN加速功能初步应用</title><link href="http://localhost:4000/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment/" rel="alternate" type="text/html" title="AWS CloudFront CDN加速功能初步应用" /><published>2019-03-03T06:46:49+08:00</published><updated>2019-03-03T06:46:49+08:00</updated><id>http://localhost:4000/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment</id><content type="html" xml:base="http://localhost:4000/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment/">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Amazon CloudFront 是一项快速内容分发网络 (CDN) 服务，可以安全地以低延迟和高传输速度向全球客户分发数据、视频、应用程序和 API。&lt;/p&gt;

&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;Amazon CloudFront可以使用在如下场景中:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;静态资源缓存
    &lt;ul&gt;
      &lt;li&gt;默认提供多层缓存和区域性边缘缓存站点，可在对象尚未缓存在边缘站点时缩短延迟并降低来源服务器上的负载。缓存静态内容可为您提供所需的性能和规模，以便在浏览者访问您的站点时为其提供快速可靠的访问体验。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态内容和API加速
    &lt;ul&gt;
      &lt;li&gt;可用于保护并加速您的 WebSocket 流量及 API 调用。与客户端的 TLS 连接将在附近的边缘站点终止，然后，CloudFront 将使用经过优化的 AWS 主干网络路径安全地访问您的 API 服务器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;直播/视频加速
    &lt;ul&gt;
      &lt;li&gt;以持续的高吞吐量来流式处理您的媒体内容（包括预录制文件和现场直播），从而满足您向全球浏览者分发媒体内容的需求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;提升安全性
    &lt;ul&gt;
      &lt;li&gt;CloudFront 可与 AWS Shield 无缝集成以提供第 3/4 层 DDoS 缓解，并可与 AWS WAF 集成以提供第 7 层防护。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;软件分发
    &lt;ul&gt;
      &lt;li&gt;无论您的用户在何处，您都可以通过内容分发网络让您的软件在边缘可用。CDN 的高数据传输速率可加快您的二进制文件的分发速度，从而改善客户体验并降低成本。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;h3 id=&quot;部署服务&quot;&gt;部署服务&lt;/h3&gt;
&lt;p&gt;在使用Amazon CloudFront功能签,你应该已经有一些存储在Amazon云上的文件或者部署好的网站了.
下面我们以一个已经在AWS EC2上部署好的静态博客网站服务为例进行介绍.&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;h3 id=&quot;选择内容分发方式&quot;&gt;选择内容分发方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web
    &lt;ul&gt;
      &lt;li&gt;适用于加速静态和动态的网站内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RTMP
    &lt;ul&gt;
      &lt;li&gt;适合使用 Adobe Flash Media Server 的 RTMP 协议的流媒体文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分情况下都是选用web内容分发方式,我们这里是用于博客网站加速,所以选用的也是web内容分发方式.&lt;/p&gt;

&lt;h3 id=&quot;创建分配&quot;&gt;创建分配&lt;/h3&gt;
&lt;p&gt;创建分配规则最主要的关注如下几个配置项:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;源域名
    &lt;ul&gt;
      &lt;li&gt;选择需要加速的资源来源,支持直接选择存储在AWS S3数据库之中的内容如果是自建网站,那么填写我们的网站域名即可.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;源协议策略
    &lt;ul&gt;
      &lt;li&gt;选择兼顾HTTP与HTTPS的协议策略,方便后续网站协议变更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端口
    &lt;ul&gt;
      &lt;li&gt;根据自己的网络服务配置情况进行填写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他的配置使用默认即可&lt;/p&gt;

&lt;h3 id=&quot;使用内容分发&quot;&gt;使用内容分发&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/2019-03-02-AWS-cloudfront-basic-deployment.png&quot; alt=&quot;&quot; /&gt;
创建完内容分发配置之后,等待其状态变为已部署就可以使用了.
AWS CloudFront会重新分配一个域名,用户使用这个域名进行内容分发即可达到用户的最优访问效果了.&lt;/p&gt;

&lt;h3 id=&quot;额外功能&quot;&gt;额外功能&lt;/h3&gt;
&lt;p&gt;Amazon CloudFront还提供了各种的报告和分析功能,用户可以通过Amazon提供的数据查看缓存使用的状态,包括请求数、字节数、HTTP状态、异常报告等等&lt;/p&gt;</content><author><name>Shore</name></author><category term="架构" /><category term="云计算" /><summary type="html">简介 Amazon CloudFront 是一项快速内容分发网络 (CDN) 服务，可以安全地以低延迟和高传输速度向全球客户分发数据、视频、应用程序和 API。</summary></entry><entry><title type="html">在AWS Ubuntu服务器上使用Docker快速部署Jekyll静态博客</title><link href="http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/02/26/Deploy-Jekyll-by-docker-in-AWS/" rel="alternate" type="text/html" title="在AWS Ubuntu服务器上使用Docker快速部署Jekyll静态博客" /><published>2019-02-26T06:46:49+08:00</published><updated>2019-02-26T06:46:49+08:00</updated><id>http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/02/26/Deploy-Jekyll-by-docker-in-AWS</id><content type="html" xml:base="http://localhost:4000/%E5%B7%A5%E5%85%B7/2019/02/26/Deploy-Jekyll-by-docker-in-AWS/">&lt;h2 id=&quot;jekyll简介&quot;&gt;Jekyll简介&lt;/h2&gt;
&lt;p&gt;Jekyll 是一个简单且完全免费的静态博客站点生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个只用 Markdown (或 Textile)、Liquid、HTML &amp;amp; CSS 就可以生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。&lt;/p&gt;

&lt;h2 id=&quot;docker简介&quot;&gt;Docker简介&lt;/h2&gt;
&lt;p&gt;Docker是一个开放源代码软件项目，让应用程序部署的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。&lt;/p&gt;

&lt;h2 id=&quot;jekyll部署&quot;&gt;Jekyll部署&lt;/h2&gt;
&lt;h3 id=&quot;环境&quot;&gt;环境&lt;/h3&gt;
&lt;p&gt;AWS Ubuntu 16.04.5 LTS&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;h4 id=&quot;docker安装&quot;&gt;Docker安装&lt;/h4&gt;
&lt;p&gt;Docker的安装资料已经十分丰富了，参见官网指导即可。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/ubuntu/&quot;&gt;Get Docker CE for Ubuntu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;jekyll安装&quot;&gt;Jekyll安装&lt;/h4&gt;
&lt;p&gt;因为使用Docker，所以免去了Jekyll安装。不用再关心系统版本、依赖组件之类的问题，开箱即用。&lt;/p&gt;

&lt;h3 id=&quot;选择jekyll模板&quot;&gt;选择Jekyll模板&lt;/h3&gt;
&lt;p&gt;网上有大量的现成Jekyll模板可以选择，此处以Jekyll-Now为例。
在服务器上创建一个目录并git clone模板代码：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir jekyllBlog
cd jekyllBlog
git clone https://github.com/barryclark/jekyll-now.git .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;构建&quot;&gt;构建&lt;/h3&gt;
&lt;p&gt;Jekyll提供了一条build命令将模板编译为静态网页，直接在执行如下Docker命令即可：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JEKYLL_VERSION=3.8
docker run --rm --volume=&quot;$PWD:/srv/jekyll&quot; -it jekyll/jekyll:$JEKYLL_VERSION jekyll build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到新生成一个_site目录，就是刚刚构建出来的网页文件&lt;/p&gt;

&lt;h3 id=&quot;开启服务&quot;&gt;开启服务&lt;/h3&gt;
&lt;p&gt;Jekyll 同时也集成了一个网页服务，通过server命令即可开启。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --rm --volume=&quot;$PWD:/srv/jekyll&quot; -it -p 4000:4000 jekyll/jekyll:$JEKYLL_VERSION jekyll server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过-p参数指定了对外暴露的的服务器端口为4000&lt;/p&gt;

&lt;p&gt;至此，我们就可以通过服务器的IP加端口（例如http://1.2.3.4:4000）访问刚刚创建好的静态博客系统了。
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/jekyllStartupPage.png&quot; alt=&quot;jekyllstartuppage&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考资料&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/53470794/setup-jekyll-via-docker&quot;&gt;Setup Jekyll via Docker? - Stack Overflow&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="工具" /><summary type="html">Jekyll简介 Jekyll 是一个简单且完全免费的静态博客站点生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个只用 Markdown (或 Textile)、Liquid、HTML &amp;amp; CSS 就可以生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。</summary></entry><entry><title type="html">使用NGINX Ingress进行Kubernetes集群负载均衡</title><link href="http://localhost:4000/2018/12/25/k8s-nginx-ingress-install/" rel="alternate" type="text/html" title="使用NGINX Ingress进行Kubernetes集群负载均衡" /><published>2018-12-25T08:23:23+08:00</published><updated>2018-12-25T08:23:23+08:00</updated><id>http://localhost:4000/2018/12/25/k8s-nginx-ingress-install</id><content type="html" xml:base="http://localhost:4000/2018/12/25/k8s-nginx-ingress-install/">&lt;h2 id=&quot;1-概述&quot;&gt;1 概述&lt;/h2&gt;
&lt;p&gt;Nginx Ingress Controller 是 Kubernetes Ingress Controller 的一种实现，作为反向代理将外部流量导入集群内部，实现将 Kubernetes 内部的 Service 暴露给外部，这样我们就能通过公网或内网直接访问集群内部的服务。&lt;/p&gt;

&lt;h2 id=&quot;2-安装&quot;&gt;2 安装&lt;/h2&gt;
&lt;p&gt;Ingress的安装方式有两种&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;通过Kubernetes配置文件安装&lt;br /&gt;
Ingress相关的yaml文件归档在如下地址：&lt;a href=&quot;https://github.com/nginxinc/kubernetes-ingress/tree/master/deployments&quot;&gt;kubernetes-ingress/deployments at master · nginxinc/kubernetes-ingress · GitHub&lt;/a&gt;
可以通过下载相关文件后使用kubectl apply直接进行部署，参阅指导文档&lt;a href=&quot;https://github.com/nginxinc/kubernetes-ingress/blob/master/docs/installation.md&quot;&gt;kubernetes-ingress/installation.md at master · nginxinc/kubernetes-ingress · GitHub&lt;/a&gt;，此处不予赘述&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Helm安装&lt;br /&gt;
本文主要介绍通过Helm安装使用Ingress，所以开始前请确保已经安装好Helm了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;21-选择服务暴露方式&quot;&gt;2.1 选择服务暴露方式&lt;/h3&gt;
&lt;p&gt;Ingress对外部提供服务通常选择如下两种方式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LoadBalancer&lt;br /&gt;
需要云厂商支持并购买，为每个LoadBalancer类型的Service分配公网IP地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;hostPort&lt;br /&gt;
hostPort是直接将容器的端口与所调度的节点上的端口连接起来，这样用户就可以通过宿主机的IP加上端口号来访问Pod了，如:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: influxdb
spec:
  containers:
    - name: influxdb
      image: influxdb
      ports:
        - containerPort: 8086
          hostPort: 8086
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;hostPort的方案有个缺点，因为Pod重新调度的时候该Pod被调度到的宿主机可能会变动，这样就变化后用户必须自己维护一个Pod与所在宿主机的对应关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;22-使用loadbalancer提供服务&quot;&gt;2.2 使用LoadBalancer提供服务&lt;/h3&gt;
&lt;p&gt;这种方式部署起来十分简单，因为stable/nginx-ingress这个helm包默认就是使用这种方式部署。确保在云厂商上已经开通了LoadBalancer服务之后，执行如下命令进行一键安装：&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;helm install --name nginx-ingress --namespace kube-system stable/nginx-ingress&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;部署完成后查看结果：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get svc -n kube-system
NAME                            TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)                      AGE
nginx-ingress-controller        LoadBalancer   10.3.255.138   119.28.121.125   80:30113/TCP,443:32564/TCP   21h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-使用hostport提供服务&quot;&gt;2.3 使用hostPort提供服务&lt;/h3&gt;
&lt;p&gt;之前有提到hostPort的缺点在于Pod被调度变化到其他宿主机时需要手动维护。那么我们通过DaemonSet将Nginx 的 Ingress Controller Pod指定到特定宿主机上面来解决这个问题，牺牲了一定的可靠性，但就可以不再操心如何手工维护服务的地址变化问题了，二者的利弊取舍可以根据使用场景进行评估。&lt;/p&gt;

&lt;h4 id=&quot;231-选择边缘节点&quot;&gt;2.3.1 选择边缘节点&lt;/h4&gt;
&lt;p&gt;边缘节点：监听外部流量进入集群内部的节点
这里我们选择集群内部的一个节点作为边缘节点，注意这个节点需要有外部可以访问的公网地址并且80、443端口没有被其他应用占用。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-cluster1-master ~]# kubectl get nodes
NAME                      STATUS   ROLES    AGE   VERSION
izj6cfiv0zhc0j2k7ruyhsz   Ready    &amp;lt;none&amp;gt;   16d   v1.13.0
k8s-cluster1-master       Ready    master   16d   v1.13.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以这个集群为例，我们选择izj6cfiv0zhc0j2k7ruyhsz作为边缘节点&lt;/p&gt;

&lt;h4 id=&quot;232-为边缘节点添加标签&quot;&gt;2.3.2 为边缘节点添加标签&lt;/h4&gt;
&lt;p&gt;我们使用如下指令给这个节点加上一个内容为node:edge的label，后续在DaemonSet部署时根据label进行绑定即可。&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl label node izj6cfiv0zhc0j2k7ruyhsz node=edge
node &quot;izj6cfiv0zhc0j2k7ruyhsz&quot; labeled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;删除标签可以使用如下命令&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl label node izj6cfiv0zhc0j2k7ruyhsz node-
node &quot;izj6cfiv0zhc0j2k7ruyhsz&quot; labeled
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;233-使用helm安装ingress&quot;&gt;2.3.3 使用helm安装ingress&lt;/h4&gt;
&lt;p&gt;配置好边缘节点之后即可以使用Helm安装ingress了，安装命令如下：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;helm install stable/nginx-ingress \
  --namespace kube-system \
  --name nginx-ingress \
  --set controller.kind=DaemonSet \
  --set controller.daemonset.useHostPort=true \
  --set controller.nodeSelector.node=edge \
  --set controller.service.type=ClusterIP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数解释：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;namespace  可选项，配置后可指定ingress安装的命令空间，默认为default&lt;/li&gt;
  &lt;li&gt;name  生成的资源名称&lt;/li&gt;
  &lt;li&gt;set controller.kind=DaemonSet  选择部署方式为DaemonSet&lt;/li&gt;
  &lt;li&gt;set controller.daemonset.useHostPort=true  开启hostPort功能，可以直接通过节点访问ingress服务&lt;/li&gt;
  &lt;li&gt;controller.nodeSelector.node=edge  提供对外提供服务的节点筛选方式，需要和之前配置的节点label匹配，例如之前配置的node=edge，这里也需要填上一样的键值&lt;/li&gt;
  &lt;li&gt;set controller.service.type=ClusterIP  内部服务的类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安装完成之后检查一下对应pod是否都正常运行了&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-cluster1-master ~]# kubectl get pods -n kube-system | grep nginx-ingress
nginx-ingress-controller-hv8h9                   1/1     Running   0          15d
nginx-ingress-default-backend-56d99b86fb-4jlxn   1/1     Running   0          15d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-配置&quot;&gt;3 配置&lt;/h2&gt;
&lt;h3 id=&quot;31-创建测试服务&quot;&gt;3.1 创建测试服务&lt;/h3&gt;
&lt;p&gt;Ingress安装完成之后，就可以配置相应规则来对外暴露服务了。我们可以创建一个服务来测试
创建一个my-nginx.yaml，内容为&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: my-nginx
spec:
  replicas: 1
  template:
    metadata:
      labels:
        run: my-nginx
    spec:
      containers:
      - name: my-nginx
        image: nginx
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: my-nginx
  labels:
    app: my-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
    name: http
  selector:
    run: my-nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl apply -f my-nginx.yaml&lt;/code&gt;进行创建，通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get service&lt;/code&gt;可以看到my-nginx服务已经创建成功&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-cluster1-master ~]# kubectl get svc
NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
kubernetes                           ClusterIP   10.96.0.1        &amp;lt;none&amp;gt;        443/TCP          17d
my-nginx                             ClusterIP   10.100.181.157   &amp;lt;none&amp;gt;        80/TCP,443/TCP   13d
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-创建ingress规则&quot;&gt;3.2 创建ingress规则&lt;/h3&gt;
&lt;p&gt;创建完成服务之后，我们就可以通过配置ingress规则来暴露服务了，&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: my-nginx
  annotations:
    kubernetes.io/ingress.class: &quot;nginx&quot;
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: www.10cloud.tk
    http:
      paths:
      - path: /web
        backend:
          serviceName: my-nginx
          servicePort: 80
  tls:
  - hosts:
    - www.10cloud.tk
    secretName: www-10cloud-tk-tls
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;参数解释&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kubernetes.io/ingress.class: “nginx”&lt;br /&gt;
通过定义kubernetes.io/ingress.class 这个annotation可以在有多个ingress controller的情况下能够让请求被我们安装的这个处理&lt;/li&gt;
  &lt;li&gt;nginx.ingress.kubernetes.io/rewrite-target: /&lt;br /&gt;
配置位置重定向，作用是使Ingress以根路径转发到后端，避免访问路径错误配置而导致的404错误。参数详细说明参照&lt;a href=&quot;https://github.com/kubernetes/ingress-nginx/tree/master/docs/examples/rewrite&quot;&gt;ingress-nginx/docs/examples/rewrite at master · kubernetes/ingress-nginx · GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;host&lt;br /&gt;
域名地址&lt;/li&gt;
  &lt;li&gt;path&lt;br /&gt;
外部访问的相对地址&lt;/li&gt;
  &lt;li&gt;backend&lt;br /&gt;
通过配置服务名称和服务端口来指定和path绑定的后端服务&lt;/li&gt;
  &lt;li&gt;tls&lt;br /&gt;
创建了证书之后，可以通过tls绑定已创建的secret来实现https安全访问功能&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，我们的Ingress创建完成并且通过配置服务与域名的关系，实现了外部访问的功能，通过域名&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chenshuo.tk/web&lt;/code&gt;即看到nginx的内容，说明通过域名已经可以访问集群内的服务了&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Welcome to nginx!
If you see this page, the nginx web server is successfully installed and working. Further configuration is required.

For online documentation and support please refer to nginx.org.
Commercial support is available at nginx.com.

Thank you for using nginx.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Shore</name></author><category term="Kubernetes" /><summary type="html">1 概述 Nginx Ingress Controller 是 Kubernetes Ingress Controller 的一种实现，作为反向代理将外部流量导入集群内部，实现将 Kubernetes 内部的 Service 暴露给外部，这样我们就能通过公网或内网直接访问集群内部的服务。</summary></entry></feed>