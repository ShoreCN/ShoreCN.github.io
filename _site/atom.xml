<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="/atom.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2024-03-19T12:00:09+08:00</updated><id>/atom.xml</id><title type="html">Shore Space</title><subtitle>C/Python/通信/云计算/Docker/K8S</subtitle><author><name>Shore</name></author><entry><title type="html">神经网络和深度学习简史</title><link href="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/2024/03/18/the-history-of-neural-networks/" rel="alternate" type="text/html" title="神经网络和深度学习简史" /><published>2024-03-18T21:00:01+08:00</published><updated>2024-03-18T21:00:01+08:00</updated><id>/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/2024/03/18/the-history-of-neural-networks</id><content type="html" xml:base="/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/2024/03/18/the-history-of-neural-networks/">&lt;h2 id=&quot;神经网络和深度学习简史&quot;&gt;神经网络和深度学习简史&lt;/h2&gt;

&lt;p&gt;March 17, 2024&lt;/p&gt;

&lt;p&gt;TL;DR 本文8200+字，全文阅读约需15分钟。本文简要回顾了从感知机到深度学习最新大模型应用 ChatGPT 的历史。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;生活中没有什么可怕的东西，只有需要理解的东西。&lt;/p&gt;

  &lt;p&gt;—— 居里夫人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一-深度信念网络&quot;&gt;一 深度信念网络&lt;/h2&gt;

&lt;p&gt;2006年，加拿大多伦多大学教授杰弗里·辛顿在研究如何训练多层神经网络，他已经在神经网络领域默默耕耘了三十多年，尽管在这个领域他算得上是泰斗级的人物，但由于神经网络在人工智能行业一直不被看好，所以他的研究成果一直不为业界所重视。&lt;/p&gt;

&lt;p&gt;辛顿出生于英国伦敦，他的家族出过不少知名学者，创立布尔代数的逻辑学家乔治·布尔便是他的曾曾祖父。他的祖父是位科普作家，父亲是昆虫学家。辛顿比周围的人都要聪明，但他的求学之路却颇为曲折，先是在大学攻读建筑学，转而又选择物理学，后又改读哲学，最后以心理学学士身份毕业。1972年辛顿进入爱丁堡大学攻读博士学位，研究方向是神经网络。彼时神经网络被业界所鄙夷，连辛顿的导师也认为这玩意没什么实际用途，也没有前途可言。但辛顿却不为所动，对神经网络研究怀有信心，坚持认为能够证明神经网络的价值，这一坚持就是三十多年。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/people/geoffery-hinton.jpg&quot; alt=&quot;geoffery-hinton.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;辛顿年轻的时候有一次搬移取暖器，腰椎间盘滑脱了，此后便一直饱受腰背病痛问题的困扰。近年来，问题更严重了，大多数时候，他需要平躺着以缓解疼痛，这意味着他不能开车，也不能坐飞机，甚至在实验室里会见学生时，也要平躺在办公室的折叠床上。身体上疼痛的折磨带给辛顿的打击还不如学术研究被冷漠那么大。早在1969年，明斯基在《感知机》一书中就对多层感知机下了定论，给后来的神经网络研究盖戳：“多层感知机不会有发展前景，因为世界上没人可以将多层感知机训练得足够好，哪怕是令它可以学会最简单的函数方法。” 单层感知机能力有限，连“异或”这种基础的分类问题也实现不了，而多层感知机又没有可用的训练方法，等于说神经网络的研究方向是死路一条。神经网络在业界被认为是学术异端，没有人相信它可以成功，因此一般学生在选择导师的时候都谨慎绕开神经网络，一时间辛顿甚至都招不满研究生。&lt;/p&gt;

&lt;p&gt;1983年，辛顿发明玻尔兹曼机，后来，简化后的受限玻尔兹曼机被应用于机器学习，成为深度神经网络的层级结构基础。1986年，辛顿提出适用于多层感知机的误差反向传播算法（BP），这一算法奠定了后来深度学习的基础。辛顿每隔一段时间都能发明出新东西，而他也坚持写了两百多篇神经网络相关的论文，尽管这些论文不被待见。到了2006年，辛顿已经积累了丰富的理论和实践基础，而这一次，他发表的论文将改变整个机器学习乃至整个世界。&lt;/p&gt;

&lt;p&gt;辛顿发现，拥有多个隐藏层的神经网络能够具有自动提取特征学习的能力，相比传统的手工提取特征的机器学习更有效果。另外，通过逐层预训练的方式可以降低多层神经网络的训练难度，而这解决了长期以来多层神经网络训练的难题。辛顿将他的研究成果发表在两篇论文中，而当时神经网络一词被许多学术期刊编辑所排斥，有些稿件的标题甚至因为包含“神经网络”就会被退回。为了不刺激这些人的敏感神经，辛顿取了个新名字，将该模型命名为“深度信念网络”（Deep Belief Network）。&lt;/p&gt;

&lt;h2 id=&quot;二-感知机&quot;&gt;二 感知机&lt;/h2&gt;

&lt;p&gt;其实神经网络的研究可以追溯到上世纪四十年代。1940年，17岁的沃尔特·皮茨在伊利诺伊大学芝加哥分校结识了42岁的教授沃伦·麦卡洛克，一见如故，便加入了后者的研究项目：尝试用神经元网络建立一个在逻辑运算基础上的机械性的大脑思维模型。他们用逻辑运算来抽象人类大脑的思维模型，提出了“神经网络”（Neural Network）这一概念，而神经元是神经网络中的最小信息处理单元；并且他们将神经元的工作过程抽象简化成一个非常简单的逻辑运算模型，后来这个模型被命名为“M-P神经元模型”，以他们两姓名的首字母来命名。&lt;/p&gt;

&lt;p&gt;在这个模型中，一个神经元会接受过个来自于其他神经元传递过来的输入信号，不同的输入信号的重要性有差异，这种差异就通过连接上的“权重”（weight）大小来表示，该神经元将所有输入值按照权重加权求和，再将结果跟神经元的“激发阈值”（Threshold）进行比较，以决定是否对外输出信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/m-p-model.png&quot; alt=&quot;m-p-model.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“M-P模型”足够简单直接，而且可以通过符号逻辑来模拟实现，人工智能专家以该模型为基础，构建了神经网络模型，用来解决机器学习任务。这里简单说明下人工智能、机器学习和深度学习的关系：人工智能就是使用计算机技术来实现人类智能的技术，在一般教材定义为研究与构建智能体。智能体就是 Intelligent agent，或简称 agent，它通过模仿人类思维和认知来解决特定任务或通用任务，解决特性任务的智能体被称为弱人工智能，或狭义人工智能（ANI），而解决通用任务的智能体被称为强人工智能，或通用人工智能（AGI）。机器学习是人工智能的一个分支，它通过数据进行学习并改进系统。而深度学习则又是机器学习的一个分支，它使用神经网络技术进行机器学习。&lt;/p&gt;

&lt;p&gt;1957年，康奈尔大学心理学教授罗森布拉特在IBM计算机上模拟实现了一个神经网络模型，他称之为“感知机”（Perceptron）。他的做法是将一组M-P模型神经元组合在一起，可以用来训练并完成一些机器视觉模式识别方面的任务。一般来说，机器学习有两种任务：分类和回归。分类问题是判断数据是哪一类的问题，比如识别图像是猫还是狗；而回归问题是根据一个数据预测另一个数据的问题，比如根据人的图像预测其体重。感知机解决的是线性分类问题。以《智慧的疆界》书中对感知机工作原理的举例来解释：&lt;/p&gt;

&lt;p&gt;假设任务目标是自动识别阿拉伯数字，待识别的数字是将手写或印刷的各种形式的数字，将数字通过扫描后存储在14*14像素大小的图片文件中。首先，要准备类似下图的训练集供机器学习用。训练集即训练数据集，是专门提供给计算机学习使用的数据集，它不仅是一组图片之类的数据，还会由人工事先标注告诉机器这些图片数据代表的数字是什么。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/numbers-datasets.jpeg&quot; alt=&quot;numbers-datasets.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，我们要设计一种数据结构，以便机器可以存储并处理这些图片。对于14*14的灰度数字图片，可以将黑色像素用1来表示，白色像素用0表示，介于黑白间的灰度像素根据其灰度强度用0-1间的浮点数表示。如下图所示对该图可以转换成一个二维张量数组：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/number1-represent.jpeg&quot; alt=&quot;number1-represent.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而机器能够识别出图片中的数字是什么，主要是找到了该图片表示某个数字的特征。对于人类来说，对于识别这些手写体数字很容易，但我们很难解释这些特征是什么。机器学习的目标就是要提取出这些训练集中图片表示数字的特征，根据M-P模型，提取特征的方法就是选择对图片各个像素值进行加权求和，根据训练集中的样本图片和标注数据的对应结果来计算每个像素对应各数字的权值：如果某一个像素具有很负面的证据说明该图片不属于某个数字的话，就把该像素对应该数字的权值设置成负数，相反如果一个像素具有很正面的证据说明该图片属于某个数字，那么该像素对应该数字的权值设置成正值。比如对于数字“0”的图片中间点的像素不应该有黑色（1）像素，如果出现了则表明该图片属于数字0为负面证据，就降低该图片是数字0的概率。这样，经过对数据集的训练和校准，就可以得到14*14（=196）每个像素对应0-9各数字的权重分布。&lt;/p&gt;

&lt;p&gt;我们再将每个数字的分类过程转换成一个M-P神经元，每个神经元都有196个像素输入，每个输入与该神经元之间的权重值由训练得到，这样就构成了一个10个神经元、196个输入以及它们之前1960个带权重的连接线组成的神经网络，如下图示：（一般在神经网络中，会将阈值转换成偏置bias，称为求和项的一项，简化运算过程。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/perceptron-1.png&quot; alt=&quot;perceptron-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过，在实际情况中，有些手写字体存在模棱两可的情况，可能会导致加权求和后，出现两个或两个以上的神经元被激活。因此感知机在实现时引入了激活函数的设计，如下图中的Softmax就是一种激活函数，该函数会对求和值进行处理，抑制概率小的、增强概率大的数字分类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/perceptron-2.png&quot; alt=&quot;perceptron-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;罗森布拉特又在两年后制造了世界第一台硬件感知机”Mark-1”，该感知机可以识别英文字母，在当时可是引起了巨大轰动。美国国防部和海军军方也注意到了，并给与了大量的资金支撑，罗森布拉特对感知机的自信也达到顶点，甚至有记者问“有没有感知机做不到的事情”，罗森布拉特的回答是“爱、希望、绝望”。罗森布拉特的名气越来越大，而张扬的性格也导致他四处树敌，其中最有名的是人工智能的另一位巨头马文·明斯基。明斯基是达特茅斯会议的组织者，也是人工智能的奠基者之一。1969年，他出版了《感知机》一书，该书明确指出了感知机存在的缺陷。首先是通过数学方法证明了感知机无法处理异或等非线性分类问题，而后又证明了多层感知机的复杂度导致连接数据急剧膨胀而没有合适的训练方法。明斯基在该书出版当年获得了第四届图灵奖，巨大的声望让他对感知机的判断给神经网络研究判了死刑。连接主义备受打击，而符号主义的研究则成为人工智能的主流。&lt;/p&gt;

&lt;p&gt;人工智能领域有两大流派：连接主义和符号主义，有点像武侠小说中的剑宗和气宗，长期以来一直互相竞争。连接主义通过模拟人类的大脑构建神经网络，将知识存储在大量的连接中，基于数据学习来发展人工智能。而符号主义则是认为知识和推理都应该用符号和规则来表示，即大量的“if-then”规则定义，来产生决策和推理，基于规则和逻辑来发展人工智能。前者的代表是神经网络，后者的代表是专家系统。&lt;/p&gt;

&lt;h2 id=&quot;三-深度学习&quot;&gt;三 深度学习&lt;/h2&gt;

&lt;p&gt;随着感知机的失败，政府对人工智能领域的投入减少，人工智能进入了第一次寒冬期。而到了八十年代，以专家系统为代表的符号主义成为人工智能的主流，引发了人工智能的第二波浪潮，而神经网络研究被冷落。前文说到，只有一个人还在坚持，那就是杰弗里·辛顿。&lt;/p&gt;

&lt;p&gt;辛顿在前人的基础上，先后发明了玻尔兹曼机和误差反向传播算法，辛顿在神经网络领域的开创贡献给这个领域带来了生机，虽然从上世纪八十年代到本世纪初人工智能领域的主流仍然是知识库和统计分析，神经网络的各项技术也开始突破，其中代表性的如卷积神经网络（CNN）、长短期记忆网络（LSTM）等。到了2006年，辛顿提出深度信念网络，开启了深度学习时代。&lt;/p&gt;

&lt;p&gt;深度学习所对应的神经网络模型称为深度神经网络，这是相对浅层神经网络而言的。对于浅层神经网络而言，一般只有一个隐藏层（或称中间层），加上输入层和输出层，一共就三层。而深度神经网络的隐藏层则不止一层，对比两种神经网络：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/ndnn-dnn-compare.png&quot; alt=&quot;ndnn-dnn-compare.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;深度学习之前人们一直聚焦于浅层神经网络的原因是神经网络层数的增加会导致训练难度增加，一方面缺乏足够的算力支撑，另一方面也没有很好的算法。而辛顿提出的深度信念网络则使用误差反向传播算法并通过逐层预训练的方式来解决这一训练难题。在深度信念网络之后，深度神经网络成为机器学习的主流模型，当前热门的GPT、Llama等大模型都是由一种或多种深度神经网络构建而成。&lt;/p&gt;

&lt;p&gt;对于深度神经网络的理解可以参考上文感知机原理的介绍，将深度神经网络看成是多层多个神经元的组合，由前文可以了解，每一层输出结果跟权重、偏置和激活函数有关，而对于深度神经网络的输出还跟层数等数值相关。在深度神经网络中，这些数值可以分为两类，一类是层数、激活函数、优化器等，称为超参数（hyperparameter），它由工程师设定；另一类是权重和偏置，称为参数（parameter），它是在深度神经网络训练过程中自动得到的，寻找到合适的参数就是深度学习的目的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/deep-learning-1.png&quot; alt=&quot;deep-learning-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但问题是，一个深度神经网络包含了海量的参数，而且修改一个参数将影响其他的参数行为，因此如何找到这些参数的正确取值是个难事。我们要找出参数正确取值，并让模型能够准确输出，那就需要有一个方法能够衡量模型输出与期望输出的差距。因此深度学习训练中使用损失函数（loss function）来衡量，损失函数也被称为目标函数或代价函数。损失函数通过比较深度神经网络的预测值与真实目标值，得到损失值，来表示该神经网络模型在这个训练样本上的效果好坏。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/deep-learning-2.png&quot; alt=&quot;deep-learning-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;深度学习的方法是将损失值作为反馈信号，来对参数进行微调，以降低当前样本训练的损失值。实现这种调节的便是优化器，它来实现如梯度下降等优化算法，通过反向传播方式来更新各层神经元节点的参数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/deep-learning-3.png&quot; alt=&quot;deep-learning-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一开始会对神经网络的参数进行随机赋值，输入一批训练数据，经输入层、隐藏层到输出层，得到网络的预测输出后，根据损失函数计算损失值，这是前向传播过程；然后从输出层开始，反向沿着每一层计算参数的梯度，直到输入层，并根据梯度使用优化算法更新网络的参数，这是反向传播过程。神经网络每处理一批训练样本，参数都会向正确的方向微调，损失值也会减小，这就是训练循环。训练循环足够次数，就可以得到使损失函数最小化的参数，这样就可以得到一个好的神经网络模型。&lt;/p&gt;

&lt;p&gt;当然，实际的深度学习过程比这个要复杂得多，这里只是简要介绍下大概过程。&lt;/p&gt;

&lt;p&gt;2012年时，辛顿带领他的两名学生 Alex Krizhevsky 和 Ilya Sutskever，开发了AlexNet 神经网络，参加 ImageNet 图像识别大赛，结果获得冠军，准确率远远高出第二名。随后辛顿和他的学生成立了DNNResearch公司，专注于深度神经网络的研究。这家公司没有任何产品或资产，但 AlexNet 的成功吸引了几大互联网巨头。2012年冬天，在美加交界的太浩湖边，一场秘密的竞拍正在进行：被拍卖的对象是刚成立不久的DNNResearch，买家分别是谷歌、微软、DeepMind和百度。最后在谷歌和百度还在竞相抬价时，辛顿叫停了拍卖，选择以4400万美元卖给谷歌。2014年，谷歌又将DeepMind收入囊中。2016年，采用经典蒙特卡洛树搜索和深度神经网络结合的AlphaGo战胜了李世石，次年，又战胜了世界围棋排名第一的柯洁，AlphaGo将人工智能和深度学习推向了一个新的高潮。&lt;/p&gt;

&lt;h2 id=&quot;四-大模型&quot;&gt;四 大模型&lt;/h2&gt;

&lt;p&gt;2015年，马斯克、Stripe的CTO Greg Brockman、YC创投CEO Sam Altman 和 Ilya Sutskever、等人在加州的Resewood酒店里会面，商议创建一家人工智能实验室，以对抗大型互联网公司对人工智能技术的控制。接下来，Greg Brockman 又从谷歌、微软等公司邀请来一批研究人员，成立新的实验室，并命名为OpenAI。Greg Brockman、Sam Altman 和 Ilya Sutskever 分别担任 OpenAI的董事长、CEO 和 首席科学家。&lt;/p&gt;

&lt;p&gt;马斯克和 Sam Altman 对 OpenAI 最初的设想是非营利组织，将人工智能技术面向所有人开放，以此对抗大型互联网公司控制人工智能技术而带来的危险性。因为深度学习人工智能技术正在爆炸式的发展，谁也预料不到这项技术在未来会不会形成对人类的威胁，而开放可能是最好的应对方式。而后来2019年OpenAI为了融资发展技术而选择成立盈利子公司，并闭源其核心技术，这是后话。&lt;/p&gt;

&lt;p&gt;2017年，谷歌的工程师发表了一篇论文，名为《Attention is all you need》，在这篇论文中提出了 Transformer 神经网络架构，该架构的特点是将人类的注意力机制引入到了神经网络中。前文说到的图像识别是深度学习中的一种场景，图像数据是离散数据，之间没有关联。而现实生活中还有另外一种场景，就是处理时序型数据，比如文本，文字的上下文是有关联的，还有语音、视频等，都是时序型数据。这种时序型数据叫序列（sequence），并且实际任务中往往是将一个序列转换成另外一个序列，比如翻译，将一段中文翻译成一段英文，还有机器人问答，将一段问题转换成一段智能生成的回答，因此要用到转换器（Transformer），这也是Transformer 名称的由来。前文说到，一个神经元的激发是由它连接的输入数据加权和决定的，权重代表了连接的强度。在时序数据中，每个元素的权重也是不一样的，这跟我们日常生活的经验是一致的，比如看下面这段话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;研表究明，汉字的序顺并不定一能影阅响读，比如当你完看这句话后，才发这现里的字全是都乱的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不仅是汉字，英语等其他人类语言同样如此。这是因为我们的大脑会自动判断句子里字词的权重，在冗杂的信息里抓中重点，这就是注意力Attention。谷歌工程师将注意力机制引入到神经网络模型中，用于自然语言处理，使得机器可以“理解”人类语言的意图。随后2018年，OpenAI基于Transformer架构发布了GPT-1，2019年发布GPT-2，2020年发布GPT-3，2022年底基于GPT-3.5发布了ChatGPT人工智能问答程序，它的对话能力让人震惊，人工智能也向着AGI方向迈进了一大步。&lt;/p&gt;

&lt;p&gt;GPT全称是 Generative Pre-trained Transformer, Generative 生成式表明它的能力，能够生成新内容，Transformer 是它的基础架构，而中间的 Pre-trained 表明它的训练方式是预训练。为什么叫预训练呢？这是因为，从AlexNet开始，人们为了取得更好的效果，在神经网络训练中开始采用更大的数据和更多的参数，而这也意味着训练的资源和耗时也越来越大。这种成本对于训练特定任务有些高，且不能与其他神经网络共享，有些浪费。因此，业界开始采用一种预训练+微调的方式来训练神经网络模型，即先在较大的数据集上完成通用大模型的训练，然后在具体的任务场景用较小的数据集完成模型微调。ChatGPT采用了基于人类反馈的强化学习（Reinforcement learning from human feedback， RLHF）来进行预训练微调，分成三个步骤：第一步，预训练一个语言模型（LM）；第二步，收集问答数据并训练一个奖励模型（Reward Model，RM）；第三步，用强化学习（RL）方式微调语言模型（LM）。这个奖励模型包含了人工反馈，因此训练过程称为RLHF。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/chatgpt-training-steps.jpeg&quot; alt=&quot;chatgpt-training-steps.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户在使用ChatGPT过程中，除了赞叹它的准确度外，还被多轮对话的能力所折服。根据神经网络的底层探析，我们看到每次推理过程是从输入经各神经元加权和激活到输出，是没有记忆能力的。而ChatGPT之所以多轮对话效果好，是因为它在对话管理中使用了Prompt Engineering的技术。&lt;/p&gt;

&lt;p&gt;对于ChatGPT等大语言模型来说，它的输入是经过将一串文字转换的token，而大模型因为计算效率和内存限制，一般会设计固定的上下文窗口，限制输入token的数量。文本首先会被分词器（tokenizer）分词，并通过查表编号，然后embedding到矩阵中变成高维空间向量，这是文本向量化的过程，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/tokenization-embeding.webp&quot; alt=&quot;tokenization-embeding.webp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于token数的限制，因此要在有限的上下文窗口中将更全面的信息告诉大模型，就这需要用到Prompt Engineering提示工程技术。提示工程利用一些策略来优化模型输入，以便让模型产生更符合期望的输出。&lt;/p&gt;

&lt;p&gt;ChatGPT的成功背后是以GPT为代表的大模型的技术演进，OpenAI相信大力出奇迹，不断扩大GPT的参数，GPT-1模型参数有1.17亿，GPT-2模型参数提高到了15亿，GPT-3达到了1750亿，而GPT-4的模型参数据称有1.8万亿。更多的模型参数也就意味着需要更大的算力来支持训练，OpenAI因此总结了“Scaling Law”，称模型的性能与模型大小、数据量和计算资源有关，简单的说就是，模型越大、数据量越大、计算资源越大，模型的性能就越好。强化学习之父Rich Sutton在他的文章《苦涩的教训》(the Bitter Lesson)中也表达了类似的观点，他回顾人工智能近几十年的发展路程，总结说短期内人们总是试图通过构建知识来提升智能体的性能，但长期看强大的算力才是王道。&lt;/p&gt;

&lt;p&gt;大模型的能力也由量变转为质变，谷歌首席科学家Jeff Dean称它为大模型的“涌现能力”(Emergent abilities)。市场看到了这个机会，一方面，各大厂商在大模型投资上呈现军备竞赛之态，另一方面，大模型的开源生态也如火如荼。&lt;/p&gt;

&lt;h2 id=&quot;五-hugging-face&quot;&gt;五 Hugging Face&lt;/h2&gt;

&lt;p&gt;2016年，法国人Clément Delangue、Julien Chaumond和Thomas Wolf成立了一家公司，起名为Hugging Face，并以该emoji图标为公司Logo. Hugging Face最初开发面向年轻人的智能聊天机器人，而后他们在训练模型的过程中开发了些模型训练工具并将它们开源，后来他们甚至调转重心来做后者，这种看似“不务正业”的做法却将他们带入了一个新的赛道，成为了深度学习领域不可或缺的角色。&lt;/p&gt;

&lt;p&gt;硅谷有很多企业都是在副业上做出成就，比如Slack原来开发游戏，公司团队分布多地，在运作过程中开发了一款交流工具结果不小心火了，就是Slack。而Hugging Face的转向也类似，也是为了解决自己的痛点，2018年，谷歌发布了大模型BERT，而Hugging Face的员工便用了他们熟悉的Pytorch框架实现了BERT，将模型取名为pytorch-pretrained-bert，并将它开源到了GitHub。后来在社区的帮助下，又引入了GPT、GPT-2、Transformer-XL等一批模型，该项目便更名为pytorch-transformers。深度学习领域一直存在着两大框架Pytorch和TensorFlow之间的竞争，而研究人员为了比较两个框架的优劣，经常在两个框架间切换，因此该开源项目又增加了两个框架间的切换功能，项目名称也改成了Transformers。Transformers也成了GitHub上增长最快的项目。&lt;/p&gt;

&lt;p&gt;Hugging Face继续开发了并开源了其他一系列的机器学习工具：Datasets、Tokenizer、Diffusers……这些工具也规范了AI开发的流程，在Hugging Face之前，可以说AI开发以研究人员为主，没有一套规范的工程化方法，Hugging Face则提供了完善的AI工具集并建立了一套事实标准，也使得更多的AI开发者甚至是非AI从业者可以快速上手并训练模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.hutusi.com/images/ai/huggingface.png&quot; alt=&quot;huggingface.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着，Hugging Face又基于Git和Git LFS技术推出了托管模型、数据集、AI应用的Hugging Face Hub，到目前为止，平台上已经托管了35万模型、7.5万数据集和15万个AI应用示例。托管并开源模型和数据集，并建立全球的开源仓库中心这项工作富有创意且意义深远。上文提到，预训练+微调的方式促进了神经网络训练资源的共享，而Hugging Face Hub则更进一步，让AI开发者可以轻松复用全世界最先进的成果，并在此基础上添砖加瓦，让人人使用AI、开发AI的AI民主化成为可能。Hugging Face也被称为是机器学习领域的GitHub，或如他们的Slogan所言：构建未来的AI社区。我之前写过两篇文章，一篇《&lt;a href=&quot;https://hutusi.com/articles/the-greatest-git-commit&quot;&gt;改变世界的一次代码提交&lt;/a&gt;》介绍Git，一篇《&lt;a href=&quot;https://hutusi.com/articles/the-story-of-github-and-gitlab&quot;&gt;从零到百亿美金之路&lt;/a&gt;》介绍GitHub，而Git、GitHub、Hugging Face，我觉得它们之间存在某种传承，一种改变世界构建未来的黑客精神的传承，这也是促使我写这篇文章的原因之一。&lt;/p&gt;

&lt;h2 id=&quot;六-后记&quot;&gt;六 后记&lt;/h2&gt;

&lt;p&gt;在快要写完本文时，我看了辛顿最近在牛津大学做的一次演讲。在演讲中，辛顿介绍了人工智能领域的两大流派，一种辛顿称为逻辑方法，即符号主义；另一种他称之为生物方法，即模拟人类大脑的神经网络连接主义。而事实证明了生物方法明显战胜了逻辑方法。神经网络是模拟人类大脑理解而设计的模型，大模型也像大脑那样的工作和理解。辛顿认为，超越人脑的人工智能在未来会出现，而且会比我们预测的时间快得多。&lt;/p&gt;

&lt;h2 id=&quot;附1-大事记&quot;&gt;附1 大事记&lt;/h2&gt;

&lt;p&gt;1943年，麦卡洛克和皮茨发表“M-P神经元模型”，用数理逻辑解释并模拟人脑的计算单元，并提出神经网络这一概念。&lt;/p&gt;

&lt;p&gt;1956年，“人工智能”一词首先在达特茅斯会议上被提出。&lt;/p&gt;

&lt;p&gt;1957年，罗森布拉特提出“感知机”模型，并在两年后成功制造能够识别英文字母的硬件感知机Mark-1.&lt;/p&gt;

&lt;p&gt;1969年，明斯基发表《感知机》，书中指出的感知机缺陷沉重打击了感知机乃至神经网络的研究。&lt;/p&gt;

&lt;p&gt;1983年，辛顿发明玻尔兹曼机。&lt;/p&gt;

&lt;p&gt;1986年，辛顿发明误差反向传播算法。&lt;/p&gt;

&lt;p&gt;1989年，杨立昆(Yann LeCun)发明“卷积神经网络”(CNN)。&lt;/p&gt;

&lt;p&gt;2006年，辛顿提出深度信念网络，开启深度学习时代。&lt;/p&gt;

&lt;p&gt;2012年，辛顿和他的两个学生设计AlexNet在ImageNet大赛中以绝对优势获得冠军，深度学习被业界所重视。&lt;/p&gt;

&lt;p&gt;2015年，Google收购的DeepMind公司推出AlphaGo，2016年战胜李世石，2017年战胜柯洁。OpenAI成立。&lt;/p&gt;

&lt;p&gt;2016年，Hugging Face成立。&lt;/p&gt;

&lt;p&gt;2017年，Google发表Transformer模型论文。&lt;/p&gt;

&lt;p&gt;2018年，OpenAI基于Transformer架构发布了GPT-1。Hugging Face发布 Transformers 项目。&lt;/p&gt;

&lt;p&gt;2019年，OpenAI发布GPT-2。&lt;/p&gt;

&lt;p&gt;2020年，OpenAI发布GPT-3。Hugging Face推出Hugging Face Hub。&lt;/p&gt;

&lt;p&gt;2022年，OpenAI发布ChatGPT。&lt;/p&gt;

&lt;h2 id=&quot;附2-参考资料&quot;&gt;附2 参考资料&lt;/h2&gt;

&lt;p&gt;书籍：&lt;/p&gt;

&lt;p&gt;《智慧的疆界：从图灵机到人工智能》周志明（著） 机械工业出版社 2018年10月&lt;/p&gt;

&lt;p&gt;《深度学习革命》凯德·梅茨（著） 杜曙光（译） 中信出版社 2023年1月&lt;/p&gt;

&lt;p&gt;《Python深度学习》（第2版） 弗朗索瓦·肖莱（著） 张亮（译） 人民邮电出版社 2022年8月&lt;/p&gt;

&lt;p&gt;《深度学习入门：基于Python的理论与实现》斋藤康毅（著）陆宇杰（译）人民邮电出版社 2018年&lt;/p&gt;

&lt;p&gt;《深度学习进阶：自然语言处理》斋藤康毅（著）陆宇杰（译） 人民邮电出版社 2020年10月&lt;/p&gt;

&lt;p&gt;《这就是ChatGPT》 斯蒂芬·沃尔夫拉姆（著） WOLFRAM传媒汉化小组（译） 人民邮电出版社 2023年7月&lt;/p&gt;

&lt;p&gt;《生成式人工智能》丁磊（著）中信出版社 2023年5月&lt;/p&gt;

&lt;p&gt;《Huggingface自然语言处理详解》李福林（著）清华大学出版社 2023年4月&lt;/p&gt;

&lt;p&gt;文章：&lt;/p&gt;

&lt;p&gt;《神经网络入门》阮一峰&lt;/p&gt;

&lt;p&gt;《2012，改变人类命运的180天》远川研究所&lt;/p&gt;

&lt;p&gt;《GPT家族进化史》MetaPost&lt;/p&gt;

&lt;p&gt;《Transformer - Attention is all you need》知乎&lt;/p&gt;

&lt;p&gt;《预训练语言模型的发展历程》 知乎&lt;/p&gt;

&lt;p&gt;《提示工程指南》&lt;/p&gt;

&lt;p&gt;《ChatGPT 背后的“功臣”——RLHF 技术详解》&lt;/p&gt;

&lt;p&gt;《ChatGPT大模型技术发展与应用》&lt;/p&gt;

&lt;p&gt;《The Bitter Lesson》 Rich Sutton&lt;/p&gt;

&lt;p&gt;《专访HuggingFace CTO：开源崛起、创业故事和AI民主化》&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文转载自&lt;a href=&quot;https://hutusi.com/articles/the-history-of-neural-network&quot;&gt;从神经网络到 Hugging Face&lt;/a&gt;，作者：&lt;a href=&quot;https://hutusi.com/&quot;&gt;胡涂说&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="人工智能" /><category term="神经网络" /><summary type="html">神经网络和深度学习简史</summary></entry><entry><title type="html">应用服务软件梳理</title><link href="/%E6%9E%B6%E6%9E%84/2024/03/02/application-server-software-brief/" rel="alternate" type="text/html" title="应用服务软件梳理" /><published>2024-03-02T07:11:33+08:00</published><updated>2024-03-02T07:11:33+08:00</updated><id>/%E6%9E%B6%E6%9E%84/2024/03/02/application-server-software-brief</id><content type="html" xml:base="/%E6%9E%B6%E6%9E%84/2024/03/02/application-server-software-brief/">&lt;p&gt;&lt;img src=&quot;/resource/application-server-software.png&quot; alt=&quot;应用服务软件梳理&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最近接触到一些不常用的服务端应用软件, 正好值此之际简单整理一番&lt;/p&gt;

&lt;h1 id=&quot;应用服务软件梳理&quot;&gt;应用服务软件梳理&lt;/h1&gt;

&lt;h2 id=&quot;什么是应用服务软件&quot;&gt;什么是应用服务软件&lt;/h2&gt;
&lt;p&gt;运行在服务器之上, 可以通过监听特定的端口, 响应用户请求对外提供服务的软件&lt;/p&gt;

&lt;h2 id=&quot;根据内容进行的服务分类&quot;&gt;根据内容进行的服务分类&lt;/h2&gt;
&lt;h3 id=&quot;1-静态服务&quot;&gt;1. 静态服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;通常访问的都是静态资源, 不同用户在不同时间获取到的都是相同的内容&lt;/li&gt;
  &lt;li&gt;生成固定的HTML页面, 可以直接托管在github上, 例如Hexo,   Hugo&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-动态服务&quot;&gt;2. 动态服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;支持动态响应, 返回动态资源, 根据用户的身份权限等区别返回不同的内容和资源&lt;/li&gt;
  &lt;li&gt;需要有对应的应用服务器进行承载, 例如Halo或WordPress&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;根据场景进行的服务分类&quot;&gt;根据场景进行的服务分类&lt;/h2&gt;
&lt;h3 id=&quot;1-web服务&quot;&gt;1. web服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;提供web化服务, 例如页面服务/邮件服务/下载服务等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-http服务&quot;&gt;2. http服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;侧重于采用的是http网络协议将用户请求传输给后端, 因为现今大部分web服务器都采用的http协议, 所以http服务器在大部分情况下是和web服务器对等的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-应用服务&quot;&gt;3. 应用服务&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一个特定应用的承载容器, 需要运行时环境的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常用服务器端服务软件&quot;&gt;常用服务器端服务软件&lt;/h2&gt;
&lt;h3 id=&quot;nginx&quot;&gt;NGINX&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;开源的静态http服务软件, 主要用于反向代理/负载均衡/流量转发等&lt;/li&gt;
  &lt;li&gt;因其性能强, 稳定性高, 所以常用于和动态服务组合使用, 作为直面用户请求的服务提供灵活稳定的web服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;apache-http-server&quot;&gt;Apache http server&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;主要用于静态服务, 在性能和资源消耗上的表现弱于NGINX, 因此使用量更低&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;iis&quot;&gt;IIS&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;微软旗下的Windows系统的应用服务软件, 支持ASP.NET&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;Tomcat&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;最常用的Java应用服务软件, 提供动态服务, 需要Java运行时环境支持&lt;/li&gt;
  &lt;li&gt;Spring Boot直接内嵌Tomcat作为默认应用容器(应用服务)&lt;/li&gt;
  &lt;li&gt;虽然Tomcat也可以直接提供动态服务, 但除非流量不大的情况, Tomcat在实际场景中很少使用Tomcat直面用户, 而是会放置在NGINX等http服务后面&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jettyundertow&quot;&gt;Jetty/Undertow&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;功能和Tomcat相当, 相对Tomcat来说会更加轻量简单, 也作为Spring的应用容器选项之一&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jbosswildfly&quot;&gt;JBoss/Wildfly&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RedHat开发的平台级应用服务软件, 可以部署动态应用, 除了作为Java动态应用服务软件, 更倾向于提供整套J2EE解决方案, 比起前面几种服务软件来说属于重量级的应用服务平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;weblogic&quot;&gt;WebLogic&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Oracle出品的企业级Java应用的应用服务软件, 支持基本所有的Java功能, 作为一个商业软件提供了完整的组件.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;websphere&quot;&gt;WebSphere&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;IBM公司出品的企业级Java应用的应用服务软件, 功能强大可以和IBM的开发工具配套使用, 使用价格较高&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Shore</name></author><category term="架构" /><category term="后端" /><summary type="html"></summary></entry><entry><title type="html">个人技能树</title><link href="/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities/" rel="alternate" type="text/html" title="个人技能树" /><published>2023-08-24T23:17:19+08:00</published><updated>2023-08-24T23:17:19+08:00</updated><id>/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities</id><content type="html" xml:base="/%E4%B8%AA%E4%BA%BA/2023/08/24/personal-abilities/">&lt;p&gt;个人技能情况:
&lt;img src=&quot;/resource/个人技能树(20230822).png&quot; alt=&quot;个人技能树&quot; /&gt;&lt;/p&gt;</content><author><name>Shore</name></author><category term="个人" /><category term="简历" /><summary type="html">个人技能情况:</summary></entry><entry><title type="html">区块链代币管理</title><link href="/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager/" rel="alternate" type="text/html" title="区块链代币管理" /><published>2023-05-12T01:23:59+08:00</published><updated>2023-05-12T01:23:59+08:00</updated><id>/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager</id><content type="html" xml:base="/%E6%9E%B6%E6%9E%84/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/05/12/Blockchain-token-manager/">&lt;p&gt;区块链代币管理&lt;/p&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;区块链代币种类繁多, 如何在项目里面合理地管理代币, 这是一个问题.&lt;br /&gt;
通常情况下项目规模不大, 代币种类也不是很多, 可以直接在代码里面硬编码, 前端和后端各自独立维护, 但是这样的话, 项目的可扩展性和维护性就比较差.&lt;br /&gt;
通过设计一个简单的代币管理模块, 可以有效地解决这个问题.&lt;/p&gt;

&lt;h2 id=&quot;设计思路&quot;&gt;设计思路&lt;/h2&gt;
&lt;h3 id=&quot;明确需求&quot;&gt;明确需求&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;准确性有保证, 代币数据准确无误;&lt;/li&gt;
  &lt;li&gt;可维护性强, 统一管理代币, 避免重复劳动且容易出错;&lt;/li&gt;
  &lt;li&gt;便捷性较好, 通过设计灵活的接口, 可以适应不同的业务场景.&lt;/li&gt;
  &lt;li&gt;稳定性高, 单数据源容易出现异常时, 代币数据可能会丢失或无法读取;&lt;/li&gt;
  &lt;li&gt;可扩展性好, 代币种类可以动态增加, 代币属性可以动态修改;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;设计方案&quot;&gt;设计方案&lt;/h3&gt;
&lt;h4 id=&quot;数据结构&quot;&gt;数据结构&lt;/h4&gt;
&lt;p&gt;代币通常需要包含以下属性:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代币名称&lt;/li&gt;
  &lt;li&gt;代币符号&lt;/li&gt;
  &lt;li&gt;代币精度&lt;/li&gt;
  &lt;li&gt;代币合约地址&lt;/li&gt;
  &lt;li&gt;代币图标&lt;/li&gt;
  &lt;li&gt;链类型&lt;/li&gt;
  &lt;li&gt;协议类型&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在同一条链上, 代币符号常常无法保证唯一性, 例如: USDT, 代币名称可以保证唯一性, 例如: Tether USD.&lt;br /&gt;
在不同链上, 代币符号也可能相同, 例如: USDT.&lt;br /&gt;
所以我们需要一个唯一的标识来区分不同链上的代币, 这里我们使用代币名称+链类型来作为唯一标识.&lt;/p&gt;

&lt;h4 id=&quot;数据存储&quot;&gt;数据存储&lt;/h4&gt;
&lt;p&gt;代币数据的持久化存储, 通常有以下几种方案:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库&lt;/li&gt;
  &lt;li&gt;文件&lt;/li&gt;
  &lt;li&gt;缓存
对于token这类型的数据, 数据库可以选择非关系型数据库, 例如: mongodb, redis等.
缓存可以选择本地内存缓存, 规模较大的话, 可以选择分布式缓存, 例如: redis, memcached等.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;仅使用单数据源的话, 会存在以下问题:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;单数据源容易出现异常时, 代币数据可能会丢失或无法读取;&lt;/li&gt;
  &lt;li&gt;单数据源无法保证数据的准确性, 例如: 代币数据被恶意篡改, 或者数据更新不同步等;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这个问题, 我们可以使用多数据源的方案, 例如: 数据库+缓存, 数据库+文件等.&lt;/p&gt;

&lt;p&gt;不过多数据源的方案, 会存在数据同步的问题, 例如: 数据库+缓存, 数据库中的数据被修改后, 缓存中的数据没有及时更新, 会导致数据不一致. 通过设计一个简单的数据同步机制, 可以有效地解决这个问题.
同步机制的设计思路如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库中的数据被修改后, 通过消息队列发送消息;&lt;/li&gt;
  &lt;li&gt;缓存中的数据订阅消息队列, 收到消息后, 更新缓存中的数据;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;接口设计&quot;&gt;接口设计&lt;/h4&gt;
&lt;p&gt;代币管理系统的接口设计, 通常需要包含以下几个方面:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据初始化&lt;/li&gt;
  &lt;li&gt;数据的读取&lt;/li&gt;
  &lt;li&gt;数据的更新&lt;/li&gt;
  &lt;li&gt;数据的删除&lt;/li&gt;
  &lt;li&gt;数据的同步&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;对象设计&quot;&gt;对象设计&lt;/h4&gt;

&lt;h2 id=&quot;实现方案&quot;&gt;实现方案&lt;/h2&gt;
&lt;h3 id=&quot;数据结构-1&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;代币数据的基础结构如下:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;token_addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;precision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;logo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据存储-1&quot;&gt;数据存储&lt;/h3&gt;
&lt;p&gt;代币数据的存储方案如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据库: mongodb&lt;/li&gt;
  &lt;li&gt;缓存: LocalCache&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;接口实现&quot;&gt;接口实现&lt;/h3&gt;
&lt;p&gt;代币管理系统的接口设计如下:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;数据初始化: 从数据库中读取数据, 并写入缓存, 如果数据库中没有数据, 则从读取预先硬编码的代币数据, 并写入数据库和缓存;&lt;/li&gt;
  &lt;li&gt;数据的读取: 从缓存中读取数据, 如果缓存中没有数据, 则从数据库中读取数据, 并写入缓存;&lt;/li&gt;
  &lt;li&gt;数据的更新: 更新数据库中的数据, 并通知缓存更新数据;&lt;/li&gt;
  &lt;li&gt;数据的删除: 删除数据库中的数据, 并通知缓存删除数据;&lt;/li&gt;
  &lt;li&gt;数据的同步: 定时检查数据库和缓存中的数据是否一致, 如果不一致, 则更新缓存中的数据; 定时检查数据库中的数据和外部数据(区块链浏览器,服务提供商等)是否一致, 如果不一致, 则更新数据库中的数据;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;对象实现&quot;&gt;对象实现&lt;/h3&gt;
&lt;p&gt;以python为例, 代币管理系统的对象如下:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CryptoTokenManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cache&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cache&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;restore&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;恢复数据
        外部数据(暂无) &amp;gt; 数据库 &amp;gt; 默认数据 &amp;gt; 内存

        Returns:
            list: 恢复的数据
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;获取token信息

        Args:
            token (str): token名称
            chain (str): 链

        Returns:
            dict: token信息
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_token_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;获取token列表

        Args:
            token (str, optional): token名称. Defaults to &apos;&apos;.
            chain (str, optional): 链. Defaults to &apos;&apos;.
            protocol (str, optional): 协议. Defaults to &apos;&apos;.

        Returns:
            list: token列表
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;添加token(本地)

        Args:
            token_info (dict): token信息

        Returns:
            bool: 是否添加成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;remove_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;移除token(本地)

        Args:
            token (str): token名称
            chain (str): 链
        
        Returns:
            bool: 是否移除成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;保存至数据库

        Returns:
            bool: 是否保存成功
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;检查数据是否正确

        Returns:
            bool: 是否正确
        &quot;&quot;&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考🤔&lt;/h2&gt;
&lt;h3 id=&quot;性能优化&quot;&gt;性能优化&lt;/h3&gt;
&lt;p&gt;因为代币数据的读取频率远远大于写入频率, 所以我们可以通过缓存来提高读取性能. 作为一个相对静态的数据, 后续还可以考虑通过CDN来提升网络接口表现.&lt;/p&gt;

&lt;h3 id=&quot;安全性&quot;&gt;安全性&lt;/h3&gt;
&lt;p&gt;代币数据的安全性关键就是保证数据的准确性, 具体来说就是数据的非预期篡改, 例如: 代币数据被恶意篡改, 或者数据更新错误等.&lt;br /&gt;
不过代币管理虽然贯穿了大部分的业务流程, 但是错误的代币地址通常导致的是业务流程的失败, 而不是错误的业务流程(例如资产流向错误目标等), 所以对于安全性的提升可以更加侧重于密钥管理/收款方确认等方面.&lt;/p&gt;

&lt;h3 id=&quot;后续优化方案&quot;&gt;后续优化方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;外部数据同步&lt;/li&gt;
  &lt;li&gt;异常处理&lt;/li&gt;
  &lt;li&gt;告警机制&lt;/li&gt;
  &lt;li&gt;数据存储简化&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Shore</name></author><category term="架构" /><category term="区块链" /><category term="Python" /><category term="加密货币" /><summary type="html">区块链代币管理</summary></entry><entry><title type="html">区块链地址标准及编码解码</title><link href="/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec/" rel="alternate" type="text/html" title="区块链地址标准及编码解码" /><published>2023-04-01T23:44:29+08:00</published><updated>2023-04-01T23:44:29+08:00</updated><id>/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec</id><content type="html" xml:base="/%E5%8C%BA%E5%9D%97%E9%93%BE/2023/04/01/Blockchain-address-standard-and-codec/">&lt;p&gt;区块链地址标准及编码解码&lt;/p&gt;
&lt;h2 id=&quot;数据类型-地址-address&quot;&gt;数据类型-地址 address&lt;/h2&gt;
&lt;p&gt;在solidity里的address等价于 uint160, 即长度20字节的数值&lt;br /&gt;
在大部分开发语言内部通常使用十六进制格式进行操作(fe1f0e6efead80045af5ddb58b664fb6492230e3)&lt;br /&gt;
有时显示时加上0x标明这是一个十六进制格式(0xfe1f0e6efead80045af5ddb58b664fb6492230e3)&lt;/p&gt;

&lt;h2 id=&quot;checksum格式字符串&quot;&gt;CheckSum格式字符串&lt;/h2&gt;
&lt;p&gt;为了防止输入错误或者其他复制、粘贴、传输地址等情况出现失误, EIP-55制定了一套地址编码规则&lt;br /&gt;
样例: 0xfE1f0e6EFEad80045Af5ddb58b664fb6492230E3&lt;/p&gt;

&lt;h3 id=&quot;产生规则&quot;&gt;产生规则&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;将地址转换为十六进制结果(fe1f0e6efead80045af5ddb58b664fb6492230e3)
进行一次Keccak256哈希处理, 得到参照表(1ea1041c8817750ddd7e542a4754354676f5deb7ce20334eccf0936e81ba8726)&lt;/li&gt;
  &lt;li&gt;遍历十六进制结果的每个字符,数字跳过, 字母处理, 使用参照表里相同位置的数值进行判断, 如果小于8则不变化, 大于8则变成大写字母(fE1f0e6EFEad80045Af5ddb58b664fb6492230E3)&lt;/li&gt;
  &lt;li&gt;加上0x头, 得到最终结果(0xfE1f0e6EFEad80045Af5ddb58b664fb6492230E3)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;eth地址&quot;&gt;ETH地址&lt;/h2&gt;
&lt;p&gt;使用如上规则&lt;/p&gt;
&lt;h2 id=&quot;tron地址&quot;&gt;TRON地址&lt;/h2&gt;
&lt;h3 id=&quot;支持hex格式地址&quot;&gt;支持Hex格式地址&lt;/h3&gt;
&lt;p&gt;(官方文档说法) 同一个私钥生成的Hex格式TRON地址和以太坊地址相比，除了最前面加上41，其他完全一样&lt;br /&gt;
&lt;strong&gt;所以TRON地址是21字节长度&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;支持base58check格式地址&quot;&gt;支持Base58Check格式地址&lt;/h3&gt;
&lt;p&gt;(官方文档说法) 对Hex格式的地址进行basecheck计算得到Base58格式地址，所有账户地址的第一个字符均为T&lt;br /&gt;
样例: TWEkjtFFeVtfsdRT32Xx5KuWGcskYfhWjX&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;地址前面添加版本前缀可以影响编码结果的前导符号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;产生规则-1&quot;&gt;产生规则&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;取版本字段(41)和有效负载信息(de533fbbb750d302728d3ad29d31e070bc14af4b)，并将它们连接在一起(41de533fbbb750d302728d3ad29d31e070bc14af4b)&lt;/li&gt;
  &lt;li&gt;对第一步结果进行两次SHA256变换，取结果的前4个字节, 作为校验内容(6421c276)&lt;/li&gt;
  &lt;li&gt;将第一步结果和第二步结果连接在一起(41de533fbbb750d302728d3ad29d31e070bc14af4b6421c276)&lt;/li&gt;
  &lt;li&gt;进行base58 encode, 得到结果(TWEkjtFFeVtfsdRT32Xx5KuWGcskYfhWjX)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;但是在 TVM 虚拟机和 Solidity 编程中，需要再去掉前缀 41 成为和以太坊兼容的20字节地址格式&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;application-binary-interfaceabi&quot;&gt;Application Binary Interface(ABI)&lt;/h2&gt;
&lt;p&gt;ABI即应用二进制接口, 作为与智能合约交互的标准, 起到交互数据的作用&lt;/p&gt;

&lt;h3 id=&quot;结构&quot;&gt;结构&lt;/h3&gt;
&lt;p&gt;数据由函数选择器和参数编码组成&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;函数选择器Function Selector&lt;br /&gt;
函数签名的 Keccak（SHA-3）哈希的前 4 字节&lt;br /&gt;
基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;例如transfer(address,uint256)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;参数编码&lt;br /&gt;
从第5字节开始是被编码的参数&lt;br /&gt;
动态类型(bytes,string,list,tuple)和静态类型(其他)&lt;br /&gt;
编码规则
    &lt;ul&gt;
      &lt;li&gt;转换为十六进制之后补齐到32字节长度&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;第三方库&quot;&gt;第三方库&lt;/h3&gt;
&lt;p&gt;后端Python使用eth-abi库进行编码解码
iOS
Android&lt;/p&gt;

&lt;h3 id=&quot;调用链条&quot;&gt;调用链条&lt;/h3&gt;
&lt;h4 id=&quot;eth&quot;&gt;ETH&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前端-SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
  &lt;li&gt;后端-Web3 SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tron&quot;&gt;TRON&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;前端-SDK-编码-发送请求至节点服务商-区块链&lt;/li&gt;
  &lt;li&gt;后端-编码(eth-abi)-发送请求至节点服务商-区块链
    &lt;ul&gt;
      &lt;li&gt;编码过程中将TRON地址的首字节去除&lt;/li&gt;
      &lt;li&gt;logic.contract_tron_logic.TronContractInterface.execute_contract_func -&amp;gt; trx_abi.encode_single&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tron-地址的特殊处理&quot;&gt;TRON 地址的特殊处理&lt;/h2&gt;
&lt;p&gt;由于 EVM 中 address 为 20 字节 bytes160 类型，而 TRON 地址的 hex 地址为 21 字节， 所以在传入参数的时候需要截取后 20 字节&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TVM 对 21 字节地址只有有限的支持，建议不要依赖此特性&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;衍生&quot;&gt;衍生&lt;/h2&gt;
&lt;p&gt;bytes数据格式, 可转换为十六进制的字符串进行传递, 不需要加0x头&lt;/p&gt;

&lt;h2 id=&quot;参考产品&quot;&gt;参考产品&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;TronLink&lt;br /&gt;
进行Token转账时产生的data数据里面地址没有41前缀&lt;/li&gt;
  &lt;li&gt;imToken&lt;br /&gt;
未测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;ERC-55: Mixed-case checksum address encoding
https://eips.ethereum.org/EIPS/eip-55&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用二进制接口Application Binary Interface(ABI) 说明
https://solidity-cn.readthedocs.io/zh/develop/abi-spec.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;TRON协议-账户地址格式
https://cn.developers.tron.network/docs/&amp;gt; account#%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;TRON参数编码和解码
https://cn.developers.tron.network/docs/parameter-encoding-and-decoding&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Solidity ABI - TRON 地址的特殊处理TRON 地址的特殊处理
https://andelf.gitbook.io/tron/smart-contract/abi&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;List of address prefixes
https://en.bitcoin.it/wiki/List_of_address_prefixes&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="区块链" /><category term="加密货币" /><category term="TRON" /><category term="以太坊" /><summary type="html">区块链地址标准及编码解码 数据类型-地址 address 在solidity里的address等价于 uint160, 即长度20字节的数值 在大部分开发语言内部通常使用十六进制格式进行操作(fe1f0e6efead80045af5ddb58b664fb6492230e3) 有时显示时加上0x标明这是一个十六进制格式(0xfe1f0e6efead80045af5ddb58b664fb6492230e3)</summary></entry><entry><title type="html">公网ssh访问局域网内部Mac主机</title><link href="/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh/" rel="alternate" type="text/html" title="公网ssh访问局域网内部Mac主机" /><published>2023-01-04T18:01:00+08:00</published><updated>2023-01-04T18:01:00+08:00</updated><id>/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh</id><content type="html" xml:base="/%E5%B7%A5%E5%85%B7/2023/01/04/access-mac-host-in-LAN-via-ssh/">&lt;h1 id=&quot;需求&quot;&gt;需求&lt;/h1&gt;
&lt;p&gt;我们的日常网络应用都是基于公网IP进行的，那么如果电脑处在于某个局域网内（例如公司网络、校园网络等情况），那么就常常出现使用公网IP无法访问的情况。要解决此问题涉及如下两部分配置：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Mac端启动sshd服务&lt;/li&gt;
  &lt;li&gt;配置端口映射用以内访问内网设备&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;1mac端启动sshd服务&quot;&gt;1.Mac端启动sshd服务&lt;/h1&gt;

&lt;p&gt;系统版本：macOS High Sierra 10.13.1 (17B1003)
macOS系统自带了sshd服务，只需要启动即可，使用如下命令：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 启动sshd服务
sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 停止sshd服务
sudo launchctl unload -w /System/Library/LaunchDaemons/ssh.plist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看sshd服务情况
sudo launchctl list | grep ssh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意事项：
此处需要格外注意，必须要使用具有root权限的用户启动sshd服务，否则可能会因无法访问ssh key导致客户端ssh连接失败
ssh_exchange_identification: Connection closed by remote host&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考资料
https://www.cnblogs.com/EasonJim/p/7173859.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;2端口映射外网访问局域网内部主机&quot;&gt;2.端口映射外网访问局域网内部主机&lt;/h1&gt;

&lt;p&gt;位于公司、校园等局域网环境下面的多台主机，共用的都是一个公网IP，
所以外网直接通过此公网IP+端口访问某个局域网主机必然会产生混乱，此时就需要配置端口映射。&lt;/p&gt;

&lt;p&gt;此处访问的是ssh服务，端口号为22，无法直接访问。
那么我们可以在局域网出口路由器上定义一个未使用的端口号（例如38998），映射到内网主机的端口22，具体如下：
外网终端 &amp;lt;–&amp;gt; 局域网出口路由器38998端口 &amp;lt;–&amp;gt; 内网主机22端口&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;如此配置完之后，在外网就可以通过自定义的端口号和公网IP就可以访问内网的主机了&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh user_name@server_ip -p 38998&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果需要通过ssh拷贝文件的话，可以采用scp命令&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scp -P 38998 src_file user_name@server_ip:dst_file&lt;/code&gt;&lt;/p&gt;</content><author><name>Shore</name></author><category term="工具" /><category term="ssh" /><category term="macOS" /><summary type="html">需求 我们的日常网络应用都是基于公网IP进行的，那么如果电脑处在于某个局域网内（例如公司网络、校园网络等情况），那么就常常出现使用公网IP无法访问的情况。要解决此问题涉及如下两部分配置： Mac端启动sshd服务 配置端口映射用以内访问内网设备</summary></entry><entry><title type="html">vscode的列编辑模式</title><link href="/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode/" rel="alternate" type="text/html" title="vscode的列编辑模式" /><published>2022-11-29T00:00:00+08:00</published><updated>2022-11-29T00:00:00+08:00</updated><id>/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode</id><content type="html" xml:base="/%E5%B7%A5%E5%85%B7/2022/11/29/vscode-column-edit-mode/">&lt;h2 id=&quot;列编辑模式&quot;&gt;列编辑模式&lt;/h2&gt;
&lt;p&gt;在原来使用notepad++的时候，经常使用列编辑模式，可以快速地对多行文本进行编辑。最近使用vscode，发现vscode也有类似的功能，记录一下。&lt;/p&gt;

&lt;p&gt;目前, vscode提供了以下几种使用列编辑模式的方式:&lt;/p&gt;
&lt;h2 id=&quot;鼠标操作-多光标&quot;&gt;鼠标操作: 多光标&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;点击鼠标左键, 选择需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;这样操作会产生多个光标, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;鼠标操作-框选&quot;&gt;鼠标操作: 框选&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本的起始位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;按住鼠标左键, 拖动鼠标, 选择需要编辑的文本;&lt;/li&gt;
  &lt;li&gt;这样操作会产生一个矩形的跨行选框, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;键盘操作-多光标&quot;&gt;键盘操作: 多光标&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将光标移动到需要编辑的文本位置;&lt;/li&gt;
  &lt;li&gt;按住键盘上的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Command&lt;/code&gt;+&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;上/下&lt;/code&gt;键;&lt;/li&gt;
  &lt;li&gt;这样操作可以产生多个光标, 选择完成之后即可同时编辑多行文本;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意: 以上操作都是在MacOS系统下进行的, Windows系统下的快捷键可能会有所不同.&lt;br /&gt;
大部分情况下, 二者的快捷键可以使用如下方式对应:&lt;br /&gt;
MacOS的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Option&lt;/code&gt;键对应Windows的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Alt&lt;/code&gt;键;&lt;br /&gt;
MacOS的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Command&lt;/code&gt;键对应Windows的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ctrl&lt;/code&gt;键;&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="工具" /><category term="vscode" /><summary type="html">列编辑模式 在原来使用notepad++的时候，经常使用列编辑模式，可以快速地对多行文本进行编辑。最近使用vscode，发现vscode也有类似的功能，记录一下。</summary></entry><entry><title type="html">macOS上修复word/excel等office文件乱码问题</title><link href="/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac/" rel="alternate" type="text/html" title="macOS上修复word/excel等office文件乱码问题" /><published>2019-03-19T19:14:39+08:00</published><updated>2019-03-19T19:14:39+08:00</updated><id>/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac</id><content type="html" xml:base="/%E5%B7%A5%E5%85%B7/2019/03/19/office-on-windows-trans-encoding-on-mac/">&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;编码问题。因为在Windows系统上面，通常使用的是GBK字符编码方式，但是在macOS的系统上使用的是UTF-8的编码方式。所以常常会遇到从Windows系统上编辑创建的word/excel等office文件，在macOS或iOS上面打开显示为乱码。&lt;/p&gt;

&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;既然明白了问题产生原因是字符编码方式的差异，那么就容易处理了，我们只需要将文件的字符编码方式转换为系统支持的即可。
macOS或Linux系统下的iconv命令的作用就是进行文件编码方式转换。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iconv的作用是在多种国际编码格式之间进行文本内码的转换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: iconv [OPTION...] [-f ENCODING] [-t ENCODING] [INPUTFILE...]
or:    iconv -l

Converts text from one encoding to another encoding.

Options controlling the input and output format:
  -f ENCODING, --from-code=ENCODING
                              the encoding of the input
  -t ENCODING, --to-code=ENCODING
                              the encoding of the output

Options controlling conversion problems:
  -c                          discard unconvertible characters
  --unicode-subst=FORMATSTRING
                              substitution for unconvertible Unicode characters
  --byte-subst=FORMATSTRING   substitution for unconvertible bytes
  --widechar-subst=FORMATSTRING
                              substitution for unconvertible wide characters

Options controlling error output:
  -s, --silent                suppress error messages about conversion problems

Informative output:
  -l, --list                  list the supported encodings
  --help                      display this help and exit
  --version                   output version information and exit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过iconv尝试进行文件编码方式转换，执行命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iconv -s -c -f GBK -t UTF8 input.file &amp;gt; output.file&lt;/code&gt;&lt;br /&gt;
参数解释：&lt;br /&gt;
-f 输入文件的编码方式&lt;br /&gt;
-t 输出文件的编码方式&lt;br /&gt;
input.file 输入文件名&lt;br /&gt;
output.file 输出文件名&lt;br /&gt;
通过执行这条命令，我们打开新生成的输出文件，可以看到文件内容已经正常显示了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;iconv命令支持很多文件编码方式，具体的可以通过命令&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iconv -l&lt;/code&gt;进行查询。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="工具" /><summary type="html">原因 编码问题。因为在Windows系统上面，通常使用的是GBK字符编码方式，但是在macOS的系统上使用的是UTF-8的编码方式。所以常常会遇到从Windows系统上编辑创建的word/excel等office文件，在macOS或iOS上面打开显示为乱码。</summary></entry><entry><title type="html">在Google云平台上通过Docker快速搭建ShadowSocks服务</title><link href="/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker/" rel="alternate" type="text/html" title="在Google云平台上通过Docker快速搭建ShadowSocks服务" /><published>2019-03-06T06:46:49+08:00</published><updated>2019-03-06T06:46:49+08:00</updated><id>/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker</id><content type="html" xml:base="/%E4%BA%91%E8%AE%A1%E7%AE%97/%E5%AE%B9%E5%99%A8/2019/03/06/google-cloud-deploy-ss-on-docker/">&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;已激活的Google云账号&lt;/li&gt;
  &lt;li&gt;支付方式已经配置成功&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;创建实例&quot;&gt;创建实例&lt;/h2&gt;
&lt;p&gt;通过Google Cloud Platform左上角的导航菜单进入“Compute Engine - VM实例视图”创建VM实例
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择区域与配置&quot;&gt;选择区域与配置&lt;/h3&gt;
&lt;p&gt;目前谷歌云支持18个区域,列表如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Taiwan(asia-east1)&lt;/li&gt;
  &lt;li&gt;Hong Kong(asia-east2)&lt;/li&gt;
  &lt;li&gt;Singapore(asia-southeast1)&lt;/li&gt;
  &lt;li&gt;Tokyo(asia-northeast1)&lt;/li&gt;
  &lt;li&gt;Montreal, Canada(northamerica-northeast1)&lt;/li&gt;
  &lt;li&gt;Los Angeles, USA(us-west2)&lt;/li&gt;
  &lt;li&gt;South Carolina, USA(us-east1)&lt;/li&gt;
  &lt;li&gt;Northern Virginia, USA(us-east4)&lt;/li&gt;
  &lt;li&gt;Sydney(australia-southeast1)&lt;/li&gt;
  &lt;li&gt;Mumbai(asia-south1)&lt;/li&gt;
  &lt;li&gt;Belgium(europe-west1)&lt;/li&gt;
  &lt;li&gt;Netherlands(europe-west4)&lt;/li&gt;
  &lt;li&gt;Hamina, Finland(europe-north1)&lt;/li&gt;
  &lt;li&gt;London, UK(europe-west2)&lt;/li&gt;
  &lt;li&gt;Iowa, USA(us-central1)&lt;/li&gt;
  &lt;li&gt;Oregon, USA(us-west1)&lt;/li&gt;
  &lt;li&gt;São Paulo(southamerica-east1)&lt;/li&gt;
  &lt;li&gt;Frankfurt, Germany(europe-west3)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据业务选择适合自己的区域,通常选用访问延迟较低的区域,可以根据谷歌云主机测速网站&lt;a href=&quot;http://www.gcping.com/&quot;&gt;GCP ping&lt;/a&gt;的数据进行选择.
此处以台湾服务器为例
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;可选是否使用容器功能&quot;&gt;(可选)是否使用容器功能&lt;/h3&gt;
&lt;p&gt;Google云已经全流程支持容器功能,可以在创建实例的时候就进行容器配置
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;选择映像&quot;&gt;选择映像&lt;/h3&gt;
&lt;p&gt;如果使用容器化部署的话,系统会自动启用容器定制系统,用户就无需自己再选择映像了.
若没有使用到云平台配套的容器功能,用户可以根据需求选择合适自己的映像(即镜像)
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;防火墙配置&quot;&gt;防火墙配置&lt;/h3&gt;
&lt;p&gt;勾选允许HTTP和HTTPS流量的选项
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;连接实例&quot;&gt;连接实例&lt;/h2&gt;
&lt;p&gt;Google Cloud提供了浏览器登录、SSH登录等多种方式,选择合适自己的即可.&lt;/p&gt;

&lt;h2 id=&quot;手工使用docker部署shadowsocks服务&quot;&gt;手工使用Docker部署ShadowSocks服务&lt;/h2&gt;
&lt;p&gt;使用Google Cloud自带的容器功能可以省去一些安装配置动作.
但是手工部署可以带来更高的灵活性,用户可以选择更多的可选配置.
安装完docker相关组件之后,使用如下命令即可部署SS服务:
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -dt --name ss -p &amp;lt;host_port&amp;gt;:&amp;lt;docker_port&amp;gt; mritd/shadowsocks -s &quot;-s 0.0.0.0 -p &amp;lt;s&amp;gt; -m chacha20-ietf-poly1305 -k &amp;lt;password&amp;gt; --fast-open&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数说明:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-d: 后台运行容器，并返回容器ID；&lt;/li&gt;
  &lt;li&gt;-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；&lt;/li&gt;
  &lt;li&gt;-p: 根据“服务器端口:容器端口”格式顺序配置端口映射关系&lt;/li&gt;
  &lt;li&gt;-s: 用户自行指定参数
    &lt;ul&gt;
      &lt;li&gt;-s  服务主机IP&lt;/li&gt;
      &lt;li&gt;-p 对外暴露的服务端口&lt;/li&gt;
      &lt;li&gt;-m 选择加密方式,这里选择chacha20-ietf-poly1305&lt;/li&gt;
      &lt;li&gt;-k 配置密码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命令执行完成之后可以通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;命令查看容器是否正常运行,
使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep ss&lt;/code&gt;命令可以查看ShadowSocks服务是否正常运行.&lt;/p&gt;

&lt;p&gt;至此,用户就可以根据自己使用的终端安装对应的客户端使用ShadowSocks服务了.&lt;/p&gt;

&lt;h2 id=&quot;常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ShadowSocks安装及配置没有错误的情况下，客户端为何还是无法使用服务？
使用云服务器出现这种情况很可能是因为云厂商的网络安全策略限制所致，请确保相应的网络端口都已经打开。此处以谷歌云为例，导航菜单-VPC网络-防火墙规则-创建防火墙规则-填写允许访问的协议和端口。
&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/20190305/6.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;tips 如何快速判断是因为网络端口没有放开导致的服务不可用？&lt;br /&gt;
有时用户无法确定到底是软件安装配置还是网络端口问题导致的服务不可用。只需如下一条命令即可快速启用一个web服务&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run -p &amp;lt;hostPort&amp;gt;:80 -d nginx&lt;/code&gt;，通过访问hostIP:hostPort查看网页是否能够正常访问即可判断端口是否正常放开。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Shore</name></author><category term="云计算" /><category term="容器" /><category term="ShadowSocks" /><category term="Docker" /><category term="Google" /><summary type="html">准备 已激活的Google云账号 支付方式已经配置成功</summary></entry><entry><title type="html">AWS CloudFront CDN加速功能初步应用</title><link href="/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment/" rel="alternate" type="text/html" title="AWS CloudFront CDN加速功能初步应用" /><published>2019-03-03T06:46:49+08:00</published><updated>2019-03-03T06:46:49+08:00</updated><id>/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment</id><content type="html" xml:base="/%E6%9E%B6%E6%9E%84/2019/03/03/AWS-cloudfront-basic-deployment/">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Amazon CloudFront 是一项快速内容分发网络 (CDN) 服务，可以安全地以低延迟和高传输速度向全球客户分发数据、视频、应用程序和 API。&lt;/p&gt;

&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;Amazon CloudFront可以使用在如下场景中:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;静态资源缓存
    &lt;ul&gt;
      &lt;li&gt;默认提供多层缓存和区域性边缘缓存站点，可在对象尚未缓存在边缘站点时缩短延迟并降低来源服务器上的负载。缓存静态内容可为您提供所需的性能和规模，以便在浏览者访问您的站点时为其提供快速可靠的访问体验。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态内容和API加速
    &lt;ul&gt;
      &lt;li&gt;可用于保护并加速您的 WebSocket 流量及 API 调用。与客户端的 TLS 连接将在附近的边缘站点终止，然后，CloudFront 将使用经过优化的 AWS 主干网络路径安全地访问您的 API 服务器。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;直播/视频加速
    &lt;ul&gt;
      &lt;li&gt;以持续的高吞吐量来流式处理您的媒体内容（包括预录制文件和现场直播），从而满足您向全球浏览者分发媒体内容的需求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;提升安全性
    &lt;ul&gt;
      &lt;li&gt;CloudFront 可与 AWS Shield 无缝集成以提供第 3/4 层 DDoS 缓解，并可与 AWS WAF 集成以提供第 7 层防护。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;软件分发
    &lt;ul&gt;
      &lt;li&gt;无论您的用户在何处，您都可以通过内容分发网络让您的软件在边缘可用。CDN 的高数据传输速率可加快您的二进制文件的分发速度，从而改善客户体验并降低成本。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;h3 id=&quot;部署服务&quot;&gt;部署服务&lt;/h3&gt;
&lt;p&gt;在使用Amazon CloudFront功能签,你应该已经有一些存储在Amazon云上的文件或者部署好的网站了.
下面我们以一个已经在AWS EC2上部署好的静态博客网站服务为例进行介绍.&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;h3 id=&quot;选择内容分发方式&quot;&gt;选择内容分发方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web
    &lt;ul&gt;
      &lt;li&gt;适用于加速静态和动态的网站内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RTMP
    &lt;ul&gt;
      &lt;li&gt;适合使用 Adobe Flash Media Server 的 RTMP 协议的流媒体文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大部分情况下都是选用web内容分发方式,我们这里是用于博客网站加速,所以选用的也是web内容分发方式.&lt;/p&gt;

&lt;h3 id=&quot;创建分配&quot;&gt;创建分配&lt;/h3&gt;
&lt;p&gt;创建分配规则最主要的关注如下几个配置项:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;源域名
    &lt;ul&gt;
      &lt;li&gt;选择需要加速的资源来源,支持直接选择存储在AWS S3数据库之中的内容如果是自建网站,那么填写我们的网站域名即可.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;源协议策略
    &lt;ul&gt;
      &lt;li&gt;选择兼顾HTTP与HTTPS的协议策略,方便后续网站协议变更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;端口
    &lt;ul&gt;
      &lt;li&gt;根据自己的网络服务配置情况进行填写&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其他的配置使用默认即可&lt;/p&gt;

&lt;h3 id=&quot;使用内容分发&quot;&gt;使用内容分发&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ShoreCN/ShoreCN.github.io/master/resource/2019-03-02-AWS-cloudfront-basic-deployment.png&quot; alt=&quot;&quot; /&gt;
创建完内容分发配置之后,等待其状态变为已部署就可以使用了.
AWS CloudFront会重新分配一个域名,用户使用这个域名进行内容分发即可达到用户的最优访问效果了.&lt;/p&gt;

&lt;h3 id=&quot;额外功能&quot;&gt;额外功能&lt;/h3&gt;
&lt;p&gt;Amazon CloudFront还提供了各种的报告和分析功能,用户可以通过Amazon提供的数据查看缓存使用的状态,包括请求数、字节数、HTTP状态、异常报告等等&lt;/p&gt;</content><author><name>Shore</name></author><category term="架构" /><category term="云计算" /><summary type="html">简介 Amazon CloudFront 是一项快速内容分发网络 (CDN) 服务，可以安全地以低延迟和高传输速度向全球客户分发数据、视频、应用程序和 API。</summary></entry></feed>